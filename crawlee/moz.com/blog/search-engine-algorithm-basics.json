{
  "url": "https://moz.com/blog/search-engine-algorithm-basics",
  "slug": "search-engine-algorithm-basics",
  "title": "Search Engine Algorithm Basics - MozMoz logoMenu openMenu closeSearchMoz logo",
  "description": "A good search engine does not attempt to return the pages that best match the input query. A good search engine tries to answer the underlying question. If you become aware of this you'll understand why Google (and other search engines), use a complex algorithm to determine what results they should…",
  "content": "Search Engine Algorithm Basics Content Marketing R By: Rolf Broer December 8, 2011 The author's views are entirely their own (excluding the unlikely event of hypnosis) and may not always reflect the views of Moz. Table of Contents Copied! R By: Rolf Broer December 8, 2011 Search Engine Algorithm Basics Content Marketing The author's views are entirely their own (excluding the unlikely event of hypnosis) and may not always reflect the views of Moz. A good search engine does not attempt to return the pages that best match the input query. A good search engine tries to answer the underlying question. If you become aware of this you'll understand why Google (and other search engines), use a complex algorithm to determine what results they should return. The factors in the algorithm consist of \"hard factors\" as the number of backlinks to a page and perhaps some social recommendations through likes and +1' s. These are usually external influences. You also have the factors on the page itself. For this the way a page is build and various page elements play a role in the algorithm. But only by analyzing the on-site and off-site factors is it possible for Google to determine which pages will answer is the question behind the query. For this Google will have to analyze the text on a page. In this article I will elaborate on the problems of a search engine and optional solutions. At the end of this article we haven’t revealed Google’s algorithm (unfortunately), but we’ll be one step closer to understand some advice we often give as an SEO. There will be some formulas, but do not panic. This article isn’t just about those formulas. The article contains a excel file. Oh and the best thing: I will use some Dutch delights to illustrate the problems. Behold: Croquets are the elongated and bitterballen are the round ones ;-) True OR False Search engines have evolved tremendously in recent years, but at first they could only deal with Boolean operators. In simple terms, a term was included in a document or not. Something was true or false, 1 or 0. Additionally you could use the operators as AND, OR and NOT to search documents that contain multiple terms or to exclude terms. This sounds fairly simple, but it does have some problems with it. Suppose we have two documents, which consist of the following texts: Doc1: “And our restaurant in New York serves croquets and bitterballen.” Doc2: “In the Netherlands you retrieve croquets and frikandellen from the wall.” Oops, almost forgot to show you the frikandellen ;-) If we were to build a search engine, the first step is tokenization of the text. We want to be able to quickly determine which documents contain a term. This is easier if we all put tokens in a database. A token is any single term in a text, so how many tokens does Doc1 contain? At the moment you started to answer this question for yourself, you probably thought about the definition of a \"term\". Actually, in the example \"New York\" should be recognized as one term. How we can determine that the two individual words are actually one word is outside the scope of this article, so at the moment we threat each separate word as a separate token. So we have 10 tokens in Doc1 and 11 tokens in Doc2. To avoid duplication of information in our database, we will store types and not the tokens. Types are the unique tokens in a text. In the example Doc1 contains twice the token \"and\". In this example I ignore the fact that “and” appears once with and once without being capitalized. As with the determination of a term, there are techniques to determine whether something actually needs to be capitalized. In this case, we assume that we can store it without a capital and that “And” & “and” are the same type. By storing all the types in the database with the documents where we can find them, we’re able to search within the database with the help of Booleans. The search \"croquets\" will result in both Doc1 and Doc2. The search for \"croquets AND bitterballen\" will only return Doc1 as a result. The problem with this method is that you are likely to get too much or too little results. In addition, it lacks the ability to organize the results. If we want to improve our method we have to determine what we can use other then the presence / absence of a term in a document. Which on-page factors would you use to organize the results if you were Google? Zone Indexes A relatively simple method is to use zone indexes. A web page can be divided into different zones. Think of a title, description, author and body. By adding a weight to each zone in a document, we’re able to calculate a simple score for each document. This is one of the first on page methods search engines used to determine the subject of a page. The operation of scores by zone indexes is as follows: Suppose we add the following weights ​​to each zone: Zone Weight title 0.4 description 0.1 content 0.5 We perform the following search query: “croquets AND bitterballen” And we have a document with the following zones: Zone Content Boolean Score title New York Café 0 0 description Café with delicious croquets and bitterballen 1 0.1 content Our restaurant in New York serves croquets and bitterballen 1 0.5 Total 0.6 Because at some point everyone started abusing the weights assigned to for example the description, it became more important for Google to split the body in different zones and assign a different weight to each individual zone in the body. This is quite difficult because the web contains a variety of documents with different structures. The interpretation of an XML document by such a machine is quite simple. When interpreting an HTML document it becomes harder for a machine. The structure and tags are much more limited, which makes the analysis more difficult. Of course there will be HTML5 in the near future and Google supports microformats, but it still has its limitations. For example if you know that Google assigns more weight to content within the <content> tag and less to content in the <footer> tag, you’ll never use the <footer> tag. To determine the context of a page, Google will have to divide a web page into blocks. This way Google can judge which blocks on a page are important and which are not. One of the methods that can be used is the text / code ratio. A block on a page that contains much more text than HTML code contains probably the main content on the page. A block that contains many links / HTML code and little content is probably the menu. This is why choosing the right WYSIWYG editor is very important. Some of these editors use a a lot of unnecessary HTML code. The use of text / code ratio is just one of the methods which a search engine can use to divide a page into blocks. Bill Slawski talked about identifying blocks earlier this year. The advantage of the zone indexes method is that you can calculate quite simple a score for each document. A disadvantage of course is that many documents can get the same score. Term frequency When I asked you to think of on-page factors you would use to determine relevance of a document, you probably thought about the frequency of the query terms. It is a logical step to increase weight to each document using the search terms more often. Some SEO agencies stick to the story of using the keywords on a certain percentage in the text. We all know that isn’t true, but let me show you why. I'll try to explain it on the basis of the following examples. Here are some formulas to emerge, but as I said it is the outline of the story that matters. The numbers in the table below are the number of occurrences of a word in the document (also called term frequency or tf). So which document has a better score for the query: croquets and bitterballen ? croquets and café bitterballen Amsterdam ... Doc1 8 10 3 2 0 Doc2 1 20 3 9 2 DocN ... ... ... ... ... Query 1 1 0 1 0 The score for both documents would be as follows: score(“croquets and bitterballen”, Doc1) = 8 + 10 + 2 = 20 score(“croquets and bitterballen”, Doc2) = 1 + 20 + 9 = 30 Document 2 is in this case closer related to the query. In this example the term “and” gains the most weight, but is this fair? It is a stop word, and we like to give it only a little value. We can achieve this by using inverse document frequency (tf-idf), which is the opposite of document frequency (df). Document frequency is the number of documents where a term occurs. Inverse document frequency is, well, the opposite. As the number of documents in which a term grows, idf will shrink. You can calculate idf by dividing the total number of documents you have in your corpus by the number of documents containing the term and then take the logarithm of that quotient. Suppose that the IDF of our query terms are as follows: Idf(croquets) = 5 Idf(and) = 0.01 Idf(bitterballen) = 2 Then you get the following scores: score(“croquets and bitterballen”, Doc1) = 8*5 + 10*0.01 + 2*2 = 44.1 score(“croquets and bitterballen”, Doc2) = 1*5 + 20*0.01 + 9*2 = 23.2 Now Doc1 has a better score. But now we don’t take the length into account. One document can contain much more content then another document, without being more relevant. A long document gains a higher score quite easy with this method. Vector model We can solve this by looking at the cosine similarity of a document. An exact explanation of the theory behind this method is outside the scope of this article, but you can think about it as an kind of harmonic mean between the query terms in the document. I made an excel file, so you can play with it yourself. There is an explanation in the file itself. You need the following metrics: Query terms - each separate term in the query. Document frequency - how many documents does Google know containing that term? Term frequency - the frequency for each separate query term in the document (add this Focus Keyword widget made by Sander Tamaëla to your bookmarks, very helpful for this part) Here's an example where I actually used the model. The website had a page that was designed to rank for \"fiets kopen\" which is Dutch for “buying bikes”. The problem was that the wrong page (the homepage) was ranking for the query. For the formula, we include the previously mentioned inverse document frequency (idf). For this we need the total number of documents in the index of Google. For this we assume N = 10.4 billion. An explanation of the table below: tf = term frequency df = document frequency idf = inverse document frequency Wt,q = weight for term in query Wt,d = weight for term in document Product = Wt,q * Wt,d Score = Sum of the products The main page, which was ranking: http://www.fietsentoko.nl/ term Query Document Product tf df idf Wt,q tf Wf Wt,d Fiets 1 25.500.000 3.610493159 3.610493159 21 441 0.70711 2.55302 Kopen 1 118.000.000 2.945151332 2.9452 21 441 0.70711 2.08258 Score: 4.6356 The page I wanted to rank: http://www.fietsentoko.nl/fietsen/ term Query Document Product tf df idf Wt,q tf Wf Wt,d Fiets 1 25.500.000 3.610493159 3.610493159 22 484 0.61782 2.23063 Kopen 1 118.000.000 2.945151332 2.945151332 28 784 0.78631 2.31584 Score: 4.54647 Although the second document contains the query terms more often, the score of the document for the query was lower (higher is better). This was because the lack of balance between the query terms. Following this calculation, I changed the text on the page, and increased the use of the term “fietsen” and decreased the use of “kopen” which is a more generic term in the search engine and has less weight. This changed the score as follows: term Query Document Product tf df idf Wt,q tf Wf Wt,d Fiets 1 25.500.000 3.610493159 3.610493159 28 784 0.78631 2.83897 Kopen 1 118.000.000 2.945151332 2.945151332 22 484 0.61782 1.81960 Score: 4.6586 After a few days, Google crawled the page and the document I changed started to rank for the term. We can conclude that the number of times you use a term is not necessarily important. It is important to find the right balance for the terms you want to rank. Speed up the process To perform this calculation for each document that meets the search query, cost a lot of processing power. You can fix this by adding some static values ​​to determine for which documents you want to calculate the score. For example PageRank is a good static value. When you first calculate the score for the pages matching the query and having an high PageRank, you have a good change to find some documents which would end up in the top 10 of the results anyway. Another possibility is the use of champion lists. For each term take only the top N documents with the best score for that term. If you then have a multi term query, you can intersect those lists to find documents containing all query terms and probably have a high score. Only if there are too few documents containing all terms, you can search in all documents. So you’re not going to rank by only finding the best vector score, you have the have your statics scores right as well. Relevance feedback Relevance feedback is assigning more or less value to a term in a query, based on the relevance of a document. Using relevance feedback, a search engine can change the user query without telling the user. The first step here is to determine whether a document is relevant or not. Although there are search engines where you can specify if a result or a document is relevant or not, Google hasn’t had such a function for a long time. Their first attempt was by adding the favorite star at the search results. Now they are trying it with the Google+ button. If enough people start pushing the button at a certain result, Google will start considering the document relevant for that query. Another method is to look at the current pages that rank well. These will be considered relevant. The danger of this method is topic drift. If you're looking for bitterballen and croquettes, and the best ranking pages are all snack bars in Amsterdam, the danger is that you will assign value to Amsterdam and end up with just snack bars in Amsterdam in the results. Another way for Google is to use is by simply using data mining. They can also look at the CTR of different pages. Pages where the CTR is higher and have a lower bounce rate then average can be considered relevant. Pages with a very high bounce rate will just be irrelevant. An example of how we can use this data for adjusting the query term weights is Rochio's feedback formula. It comes down to adjusting the value of each term in the query and possibly adding additional query terms. The formula for this is as follows: The table below is a visual representation of this formula. Suppose we apply the following values ​​: Query terms: +1 (alpha) Relevant terms: +1 (beta) Irrelevant terms: -0.5 (gamma) We have the following query: “croquets and bitterballen” The relevance of the following documents is as follows: Doc1 : relevant Doc2 : relevant Doc3 : not relevant Terms Q Doc1 Doc2 Doc3 Weight new query croquets 1 1 1 0 1 + 1 – 0 = 2 and 1 1 0 1 1 + 0.5 – 0.5 = 1 bitterballen 1 0 0 0 1 + 0 - 0 = 1 café 0 0 1 0 0 + 0.5 – 0 = 0.5 Amsterdam 0 0 0 1 0 + 0 – 0.5 = -0.5 = 0 The new query is as follows: croquets(2) and(1) bitterballen(1) cafe(0.5) The value for each term is the weight that it gets in your query. We can use those weights in our vector calculations. Although the term Amsterdam was given a score of -0.5, the adjust negative values back to 0. In this way we do not exclude terms from the search results. And although café did not appear in the original query, it was added and was given a weight in the new query. Suppose Google uses this way of relevance feedback, then you could look at pages that already rank for a particular query. By using the same vocabulary, you can ensure that you get the most out of this way of relevance feedback. Takeaways In short, we’ve considered one of the options for assigning a value to a document based on the content of the page. Although the vector method is fairly accurate, it is certainly not the only method to calculate relevance. There are many adjustments to the model and it also remains only a part of the complete algorithm of search engines like Google. We have taken a look into relevance feedback as well. *cough* panda *cough*. I hope I’ve given you some insights in the methods search engine can use other then external factors. Now it's time to discuss this and to go play with the excel file :-) Copied! Back to Top",
  "headers": [
    {
      "level": "H4",
      "text": "Discover top competitors’ winning content"
    },
    {
      "level": "H4",
      "text": "What is your Brand Authority?"
    },
    {
      "level": "H4",
      "text": "Unlock flexible pricing & new endpoints"
    },
    {
      "level": "H4",
      "text": "Surface actionable competitive intel"
    },
    {
      "level": "H1",
      "text": "Search Engine Algorithm Basics"
    },
    {
      "level": "H3",
      "text": "Table of Contents"
    },
    {
      "level": "H1",
      "text": "Search Engine Algorithm Basics"
    },
    {
      "level": "H2",
      "text": "With Moz Pro, you have the tools you need to get SEO right — all in one place."
    },
    {
      "level": "H2",
      "text": "Read Next"
    },
    {
      "level": "H3",
      "text": "SEO Content Has a Packaging Problem — Whiteboard Friday"
    },
    {
      "level": "H3",
      "text": "What Is Keyword Intent and How Does It Impact Your Conversion Rate?"
    },
    {
      "level": "H3",
      "text": "Navigating Content Marketing Amidst the Rise of AI — Whiteboard Friday"
    },
    {
      "level": "H2",
      "text": "Comments"
    }
  ],
  "author": "Rolf Broer\n          \n            Rolf Broer\n          \n            Rolf Broer"
}