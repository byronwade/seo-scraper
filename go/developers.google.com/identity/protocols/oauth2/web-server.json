{
  "url": "https://developers.google.com/identity/protocols/oauth2/web-server",
  "estimatedGoogleRank": 5,
  "priorityIndicators": {
    "highPriority": {
      "contentQuality": {
        "wordCount": 7791,
        "contentUniquenessScore": 18,
        "readingLevel": "College",
        "keywordOccurrences": {
          "primaryKeyword": 269,
          "secondaryKeywords": {
            "access": 223,
            "google": 271,
            "oauth": 172,
            "token": 245
          }
        },
        "lsiTerms": [
          "'__main__'",
          "'abc",
          "'access_token'",
          "'application",
          "'authorize'"
        ],
        "textContent": "\n    \n  \n    \n      \n      \n      \n  \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n      \n        \n        \n        \n\n  \n    \n  \n\n\n\n  \n  \n  \n    \n  \n  \n    \n    \n    \n      \n      \n        \n  \n    \n    Google\n    \n  Identity\n  \n  \n      \n    \n  \n  \n\n  \n\n\n        \n          \n            \n              \n              \n  \n\n    \n      \n        \n          \n  \n    \n    Authentication\n  \n    \n  \n  \n    \n  \n  \n    \n    \n      \n        \n          \n            \n              \n                Sign In with Google S",
        "keywordDensity": 3.4527018354511614,
        "contentSections": [
          {
            "sectionTitle": "\n      Using OAuth 2.0 for Web Server Applications\n      \n    ",
            "text": "\n\n    \n    \n\n    \n      \n      Stay organized with collections\n    \n    \n      \n      Save and categorize content based on your preferences.\n    \n  \n  \n\n  \n    \n\n    \n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n  \n\n\n    \n\n    \n    This document explains how web server applications use Google API Client Libraries or Google\n      OAuth 2.0 endpoints to implement OAuth 2.0 authorization to access\n      Google APIs.\n    \n\n    OAuth 2.0 allows users to share specific data with an application while keeping their\n      usernames, passwords, and other information private. \nFor example, an application can use OAuth 2.0 to obtain permission from\nusers to store files in their Google Drives.\n\n\n    This OAuth 2.0 flow is specifically for user authorization. It is designed for applications\n      that can store confidential information and maintain state. A properly authorized web server\n      application can access an API while the user interacts with the application or after the user\n      has left the application.\n\n    Web server applications frequently also use \n      service accounts to authorize API requests, particularly when calling Cloud APIs to access\n      project-based data rather than user-specific data. Web server applications can use service\n      accounts in conjunction with user authorization.\n      \n      \n\n    \n    Note: Given the security implications of getting the implementation\n      correct, we strongly encourage you to use OAuth 2.0 libraries when interacting with Google's\n      OAuth 2.0 endpoints. It is a best practice to use well-debugged code provided by others, and\n      it will help you protect yourself and your users. For more information, see\n      Client libraries.\n    \n    \n\n    \n    \n    Client libraries\n\nThe language-specific examples on this page use\n   Google API Client Libraries to implement\n   OAuth 2.0 authorization. To run the code samples, you must first install the\n   client library for your language.\n\nWhen you use a Google API Client Library to handle your application's OAuth 2.0 flow, the client\n  library performs many actions that the application would otherwise need to handle on its own. For\n  example, it determines when the application can use or refresh stored access tokens as well as\n  when the application must reacquire consent. The client library also generates correct redirect\n  URLs and helps to implement redirect handlers that exchange authorization codes for access tokens.\n\nGoogle API Client Libraries for server-side applications are available for the following languages:\n\n\n  Go\n  Java\n  .NET\n  Node.js\n  PHP\n  Python\n  Ruby\n\n\nImportant: The Google API client\n  library for JavaScript and Sign In With Google are\n  only intended to handle OAuth 2.0 in the user's browser. If you want to use JavaScript on the\n  server-side to manage OAuth 2.0 interactions with Google, consider using the\n  Node.js library on your back-end platform.\n    \n    \n\n    \n\n    Prerequisites\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnable APIs for your project\n\nAny application that calls Google APIs needs to enable those APIs in the\n  API Console.\n\n\n\nTo enable an API for your project:\n\n\n  Open the API Library in the\n    Google API Console.\n  If prompted, select a project, or create a new one.\n\n  The API Library lists all available APIs, grouped by product\n    family and popularity. If the API you want to enable isn't visible in the list, use search to\n    find it, or click View All in the product family it belongs to.\n  Select the API you want to enable, then click the Enable button.\n  If prompted, enable billing.\n  If prompted, read and accept the API's Terms of Service.\n\n\n    \n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Create authorization credentials\n\nAny application that uses OAuth 2.0 to access Google APIs must have authorization credentials\n  that identify the application to Google's OAuth 2.0 server. The following steps explain how to\n  create credentials for your project. Your applications can then use the credentials to access APIs\n  that you have enabled for that project.\n\n\n\n\n\n    \n      Go to the Credentials page.\n      Click Create credentials > OAuth client ID.\n      Select the Web application application type.\n      Fill in the form and click Create. Applications that use languages and frameworks\n        like PHP, Java, Python, Ruby, and .NET must specify authorized redirect URIs. The\n        redirect URIs are the endpoints to which the OAuth 2.0 server can send responses. These\n        endpoints must adhere to Google’s validation rules.\n        For testing, you can specify URIs that refer to the local machine, such as\n          http://localhost:8080. With that in mind, please note that all of the\n          examples in this document use http://localhost:8080 as the redirect URI.\n        We recommend that you design your app's auth endpoints so\n          that your application does not expose authorization codes to other resources on the\n          page.\n    \n\n    After creating your credentials, download the client_secret.json file from the\n      API Console. Securely store the file in a location that only\n      your application can access.\n\n    Important: Do not store the client_secret.json file in a\n      publicly-accessible location. In addition, if you share the source code to your\n      application — for example, on GitHub — store the client_secret.json file\n      outside of your source tree to avoid inadvertently sharing your client credentials.\n\n     \n\n    \n    Identify access scopes\n\nScopes enable your application to only request access to the resources that it needs while also\n  enabling users to control the amount of access that they grant to your application. Thus, there\n  may be an inverse relationship between the number of scopes requested and the likelihood of\n  obtaining user consent.\n\nBefore you start implementing OAuth 2.0 authorization, we recommend that you identify the scopes\n  that your app will need permission to access.\n\n\nWe also recommend that your application request access to authorization scopes via an\n  incremental authorization process, in which your application\n  requests access to user data in context. This best practice helps users to more easily understand\n  why your application needs the access it is requesting.\n\n\n\n\n\n\n\nThe OAuth 2.0 API Scopes document contains a full\n  list of scopes that you might use to access Google APIs.\n\n\nIf your public application uses scopes that permit access to\n  certain user data, it must complete a verification process. If you see unverified\n  app on the screen when testing your application, you must submit a\n  verification request to remove it. Find out more about\n  unverified apps\n  and get answers to \n  frequently asked questions about app verification in the Help Center.\n\n     \n\n    \n\n    Language-specific requirements\n\n    To run any of the code samples in this document, you'll need a Google account, access to the\n      Internet, and a web browser. If you are using one of the API client libraries, also see the\n      language-specific requirements below.\n\n     \n\n    \n\n      \n\n        PHP\n\n        To run the PHP code samples in this document, you'll need:\n\n\n  PHP 5.6 or greater with the command-line interface (CLI) and JSON extension installed.\n  The Composer dependency management tool.\n  \n    The Google APIs Client Library for PHP:\n    composer require google/apiclient:^2.10\n  \n\n\n      \n\n      \n\n        Python\n\n        To run the Python code samples in this document, you'll need:\n\n\n  Python 2.6 or greater\n  The pip package management tool.\n  The Google APIs Client Library for Python:\n    pip install --upgrade google-api-python-client\n  \n  The google-auth, google-auth-oauthlib, and\n    google-auth-httplib2 for user authorization.\n    pip install --upgrade google-auth google-auth-oauthlib google-auth-httplib2\n  \n  The Flask Python web application framework.\n    pip install --upgrade flask\n  \n  The requests HTTP library.\n    pip install --upgrade requests\n  \n\n\n      \n\n      \n\n        Ruby\n\n        To run the Ruby code samples in this document, you'll need:\n\n\n  Ruby 2.6 or greater\n  \n    The Google Auth Library for Ruby:\n    gem install googleauth\n  \n  \n    The Sinatra Ruby web application framework.\n    gem install sinatra\n  \n\n\n      \n\n      \n\n        Node.js\n\n        To run the Node.js code samples in this document, you'll need:\n\n\n  The maintenance LTS, active LTS, or current release of Node.js.\n  \n    The Google APIs Node.js Client:\n    npm install googleapis crypto express express-session\n  \n\n\n      \n\n      \n\n        HTTP/REST\n\n        You do not need to install any libraries to be able to directly call the OAuth 2.0\n          endpoints.\n\n      \n\n    \n\n     \n     \n\n     \n\n    \n\n    \n\n    Obtaining OAuth 2.0 access tokens\n\nThe following steps show how your application interacts with Google's OAuth 2.0 server to obtain\n  a user's consent to perform an API request on the user's behalf. Your application must have that\n  consent before it can execute a Google API request that requires user authorization.\n\n\n\n    The list below quickly summarizes these steps:\n\n    \n      Your application identifies the permissions it needs.\n      Your application redirects the user to Google along with the list of requested\n        permissions.\n      The user decides whether to grant the permissions to your application.\n      Your application finds out what the user decided.\n      If the user granted the requested permissions, your application retrieves tokens needed to\n        make API requests on the user's behalf.\n    \n\n    \n\n    \n    \n\n    Step 1: Set authorization parameters\n\n     \n\n    Your first step is to create the authorization request. That request sets parameters that\n      identify your application and define the permissions that the user will be asked to grant to\n      your application.\n\n    \n      If you use a Google client library for OAuth 2.0 authentication and authorization, you\n        create and configure an object that defines these parameters.\n      If you call the Google OAuth 2.0 endpoint directly, you'll generate a URL and set the\n        parameters on that URL.\n    \n\n    The tabs below define the supported authorization parameters for web server applications. The\n      language-specific examples also show how to use a client library or authorization library to\n      configure an object that sets those parameters.\n\n    \n\n      \n\n        PHP\n\n        The code snippet below creates a Google\\Client() object, which defines the\n  parameters in the authorization request.\n\nThat object uses information from your client_secret.json file to identify your\n  application. (See creating authorization credentials for more about\n  that file.) The object also identifies the scopes that your application is requesting permission\n  to access and the URL to your application's auth endpoint, which will handle the response from\n  Google's OAuth 2.0 server. Finally, the code sets the optional access_type and\n  include_granted_scopes parameters.\n\n\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\n\n\n$client = new Google\\Client();\n\n// Required, call the setAuthConfig function to load authorization credentials from\n// client_secret.json file.\n$client->setAuthConfig('client_secret.json');\n\n// Required, to set the scope value, call the addScope function\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\n// Required, call the setRedirectUri function to specify a valid redirect URI for the\n// provided client_id\n$client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php');\n\n// Recommended, offline access will give you both an access and refresh token so that\n// your app can refresh the access token without user interaction.\n$client->setAccessType('offline');\n\n// Recommended, call the setState function. Using a state value can increase your assurance that\n// an incoming connection is the result of an authentication request.\n$client->setState($sample_passthrough_value);\n\n// Optional, if your application knows which user is trying to authenticate, it can use this\n// parameter to provide a hint to the Google Authentication Server.\n$client->setLoginHint('hint@example.com');\n\n// Optional, call the setPrompt function to set \"consent\" will prompt the user for consent\n$client->setPrompt('consent');\n\n// Optional, call the setIncludeGrantedScopes function with true to enable incremental\n// authorization\n$client->setIncludeGrantedScopes(true);\n\n      \n\n      \n\n        Python\n\n        The following code snippet uses the google-auth-oauthlib.flow module to construct\n  the authorization request.\n\nThe code constructs a Flow object, which identifies your application using\n  information from the client_secret.json file that you downloaded after\n  creating authorization credentials. That object also identifies the\n  scopes that your application is requesting permission to access and the URL to your application's\n  auth endpoint, which will handle the response from Google's OAuth 2.0 server. Finally, the code\n  sets the optional access_type and include_granted_scopes parameters.\n\n\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\n\n\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\n\n# Required, call the from_client_secrets_file method to retrieve the client ID from a\n# client_secret.json file. The client ID (from that file) and access scopes are required. (You can\n# also use the from_client_config method, which passes the client configuration as it originally\n# appeared in a client secrets file but doesn't access the file itself.)\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'])\n\n# Required, indicate where the API server will redirect the user after the user completes\n# the authorization flow. The redirect URI is required. The value must exactly\n# match one of the authorized redirect URIs for the OAuth 2.0 client, which you\n# configured in the API Console. If this value doesn't match an authorized URI,\n# you will get a 'redirect_uri_mismatch' error.\nflow.redirect_uri = 'https://www.example.com/oauth2callback'\n\n# Generate URL for request to Google's OAuth 2.0 server.\n# Use kwargs to set optional request parameters.\nauthorization_url, state = flow.authorization_url(\n    # Recommended, enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Optional, enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true',\n    # Optional, if your application knows which user is trying to authenticate, it can use this\n    # parameter to provide a hint to the Google Authentication Server.\n    login_hint='hint@example.com',\n    # Optional, set prompt to 'consent' will prompt the user for consent\n    prompt='consent')\n\n      \n\n      \n\n        Ruby\n\n        Use the client_secrets.json file that you created to configure a client object in your\n  application. When you configure a client object, you specify the scopes your application needs to\n  access, along with the URL to your application's auth endpoint, which will handle the response\n  from the OAuth 2.0 server.\n\n\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\n\n\nrequire 'google/apis/drive_v3'\nrequire \"googleauth\"\nrequire 'googleauth/stores/redis_token_store'\n\nclient_id = Google::Auth::ClientId.from_file('/path/to/client_secret.json')\nscope = 'https://www.googleapis.com/auth/drive.metadata.readonly'\ntoken_store = Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\nauthorizer = Google::Auth::WebUserAuthorizer.new(client_id, scope, token_store, '/oauth2callback')\n\nYour application uses the client object to perform OAuth 2.0 operations, such as generating\n  authorization request URLs and applying access tokens to HTTP requests.\n\n      \n\n      \n\n        Node.js\n\n        \n  The following code snippet creates a google.auth.OAuth2 object, which defines the\n  parameters in the authorization request.\n\n\n\n  That object uses information from your client_secret.json file to identify your application. To\n  ask for permissions from a user to retrieve an access token, you redirect them to a consent page.\n  To create a consent page URL:\n\n\nconst {google} = require('googleapis');\nconst crypto = require('crypto');\nconst express = require('express');\nconst session = require('express-session');\n\n/**\n * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI\n * from the client_secret.json file. To get these credentials for your application, visit\n * https://console.cloud.google.com/apis/credentials.\n */\nconst oauth2Client = new google.auth.OAuth2(\n  YOUR_CLIENT_ID,\n  YOUR_CLIENT_SECRET,\n  YOUR_REDIRECT_URL\n);\n\n// Access scopes for read-only Drive activity.\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly'\n];\n\n// Generate a secure random state value.\nconst state = crypto.randomBytes(32).toString('hex');\n\n// Store state in the session\nreq.session.state = state;\n\n// Generate a url that asks permissions for the Drive activity scope\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true,\n  // Include the state parameter to reduce the risk of CSRF attacks.\n  state: state\n});\n\n\n  Important Note - The refresh_token is only returned on the first\n  authorization. More details\n  \n    here.\n\n\n      \n\n      \n\n        HTTP/REST\n\n        Google's OAuth 2.0 endpoint is at https://accounts.google.com/o/oauth2/v2/auth. This\n          endpoint is accessible only over HTTPS. Plain HTTP connections are refused.\n\n      \n\n    \n\n    The Google authorization server supports the following query string parameters for web\n      server applications:\n\n    \n  \n    \n      Parameters\n    \n  \n  \n    \n      client_id\n      Required\n        The client ID for your application. You can find this value in the\n          API Console\n          Credentials page.\n        \n      \n    \n\n    \n    \n      redirect_uri\n      Required\n        \n        Determines where the API server redirects the user after the user completes the\n          authorization flow. The value must exactly match one of the authorized redirect URIs for\n          the OAuth 2.0 client, which you configured in your client's\n          API Console\n          Credentials page. If this value doesn't match an\n          authorized redirect URI for the provided client_id you will get a\n          redirect_uri_mismatch error.\n        Note that the http or https scheme, case, and trailing slash\n          ('/') must all match.\n          \n        \n      \n    \n\n    \n\n    \n      \n      \n        response_type\n        Required\n        \n        Determines whether the Google OAuth 2.0 endpoint returns an authorization code.\n          \n          Set the parameter value to code for web server applications.\n          \n        \n        \n      \n      \n    \n\n    \n      scope\n      Required\n        A\n          space-delimited\n          list of scopes that identify the resources that your application could access on the\n          user's behalf. These values inform the consent screen that Google displays to the\n          user.\n\n        Scopes enable your application to only request access to the resources that it needs\n          while also enabling users to control the amount of access that they grant to your\n          application. Thus, there is an inverse relationship between the number of scopes requested\n          and the likelihood of obtaining user consent.\n        \n        \n        \n        We recommend that your application request access to authorization scopes in context\n          whenever possible. By requesting access to user data in context, via\n          incremental authorization, you help users to more easily\n          understand why your application needs the access it is requesting.\n        \n      \n    \n\n    \n    \n      access_type\n      Recommended\n        Indicates whether your application can refresh access tokens when the user is not present\n          at the browser. Valid parameter values are online, which is the default\n          value, and offline.\n        Set the value to offline if your application needs to refresh access tokens\n          when the user is not present at the browser. This is the method of refreshing access\n          tokens described later in this document. This value instructs the Google authorization\n          server to return a refresh token and an access token the first time that your\n          application exchanges an authorization code for tokens.\n        \n      \n    \n    \n\n    \n\n    \n\n    \n    \n      state\n      Recommended\n        Specifies any string value that your application uses to maintain state between your\n          authorization request and the authorization server's response.\n          The server returns the exact value that you send as a name=value pair in the\n           URL query component (?) of the\n          redirect_uri after the user consents to or denies your application's\n          access request.\n        You can use this parameter for several purposes, such as directing the user to the\n          correct resource in your application, sending nonces, and mitigating cross-site request\n          forgery. Since your redirect_uri can be guessed, using a state\n          value can increase your assurance that an incoming connection is the result of an\n          authentication request. If you generate a random string or encode the hash of a cookie or\n          another value that captures the client's state, you can validate the response to\n          additionally ensure that the request and response originated in the same browser,\n          providing protection against attacks such as\n          cross-site request\n          forgery. See the\n          OpenID Connect\n          documentation for an example of how to create and confirm a state token.\n        \n        \n        \n          Important: The OAuth client must prevent CSRF as called out in the\n          OAuth2 Specification\n          . One way to achieve this is by using the state parameter to maintain\n          state between your authorization request and the authorization server's response.\n        \n      \n    \n    \n\n    \n    \n      include_granted_scopes\n      Optional\n        Enables applications to use incremental authorization to request access to additional\n          scopes in context. If you set this parameter's value to true and the\n          authorization request is granted, then the new access token will also cover any scopes to\n          which the user previously granted the application access. See the\n          incremental authorization section for examples.\n        \n      \n    \n    \n\n    \n    \n      enable_granular_consent\n      Optional\n        Defaults to true. If set to false,\n          more\n          granular Google Account permissions\n          will be disabled for OAuth client IDs created before 2019. No effect for newer\n          OAuth client IDs, since more granular permissions is always enabled for them.\n        When Google enables granular permissions for an application, this parameter will no\n          longer have any effect.\n      \n    \n    \n\n    \n    \n      login_hint\n      Optional\n        If your application knows which user is trying to authenticate, it can use this parameter\n          to provide a hint to the Google Authentication Server. The server uses the hint to\n          simplify the login flow either by prefilling the email field in the sign-in form or by\n          selecting the appropriate multi-login session.\n        Set the parameter value to an email address or sub identifier, which is\n          equivalent to the user's Google ID.\n        \n      \n    \n    \n\n    \n\n    \n    \n      prompt\n      Optional\n        A space-delimited, case-sensitive list of prompts to present the user. If you don't\n          specify this parameter, the user will be prompted only the first time your project\n          requests access. See \n          Prompting re-consent for more information.\n        \n\n        Possible values are:\n        \n          \n            none\n            Do not display any authentication or consent screens. Must not be specified with\n              other values.\n          \n          \n            consent\n            Prompt the user for consent.\n          \n          \n            select_account\n            Prompt the user to select an account.\n          \n        \n      \n    \n    \n  \n\n\n\n\n     \n\n     \n\n    \n\n    Step 2: Redirect to Google's OAuth 2.0 server\n\n    Redirect the user to Google's OAuth 2.0 server to initiate the authentication and\n      authorization process. Typically, this occurs when your application first needs to access the\n      user's data. In the case of incremental authorization, this\n      step also occurs when your application first needs to access additional resources that it does\n      not yet have permission to access.\n\n    \n\n    \n\n      \n\n        PHP\n\n        \n  Generate a URL to request access from Google's OAuth 2.0 server:\n    $auth_url = $client->createAuthUrl();\n  \n  Redirect the user to $auth_url:\n    header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL));\n  \n\n\n      \n\n      \n\n        Python\n\n        This example shows how to redirect the user to the authorization URL using the Flask web\n  application framework:\n\nreturn flask.redirect(authorization_url)\n\n      \n\n      \n\n        Ruby\n\n        \n  Generate a URL to request access from Google's OAuth 2.0 server:\n    auth_uri = authorizer.get_authorization_url(login_hint: user_id, request: request)\n  Redirect the user to auth_uri.\n\n\n      \n\n      \n\n        Node.js\n\n        \n  \n    Use the generated URL authorizationUrl from Step 1\n    generateAuthUrl method to request access from Google's OAuth 2.0 server.\n  \n  \n    Redirect the user to authorizationUrl.\n    res.redirect(authorizationUrl);\n  \n\n\n      \n\n      \n\n        HTTP/REST\n\n        Sample redirect to Google's authorization server\n\n        \nAn example URL is shown below, with line breaks and spaces for readability.\n\n\n        https://accounts.google.com/o/oauth2/v2/auth?\n scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly&\n access_type=offline&\n include_granted_scopes=true&\n response_type=code&\n state=state_parameter_passthrough_value&\n redirect_uri=https%3A//oauth2.example.com/code&\n client_id=client_id\n\n        After you create the request URL, redirect the user to it.\n\n      \n\n    \n\n    \n\n    Google's OAuth 2.0 server authenticates the user and obtains consent from the user for your\n      application to access the requested scopes. The response is sent back to your application\n      using the redirect URL you specified.\n\n     \n\n    \n\n    Step 3: Google prompts user for consent\n\n    In this step, the user decides whether to grant your application the requested access. At this\n  stage, Google displays a consent window that shows the name of your application and the Google API\n  services that it is requesting permission to access with the user's authorization credentials and\n  a summary of the scopes of access to be granted. The\n  user can then consent to grant access to one or more scopes requested by your application or\n  refuse the request.\n\nYour application doesn't need to do anything at this stage as it waits for the response from\n  Google's OAuth 2.0 server indicating whether any access was granted. That response is explained in\n  the following step.\n\n\n\n\nErrors\n\nRequests to Google's OAuth 2.0 authorization endpoint may display user-facing error messages\n  instead of the expected authentication and authorization flows. Common error codes and suggested\n  resolutions are listed below.\n\n\nadmin_policy_enforced\n\nThe Google Account is unable to authorize one or more scopes requested due to the policies of\n  their Google Workspace administrator. See the Google Workspace Admin help article\n  \n    Control which third-party & internal apps access Google Workspace data\n  for more information about how an administrator may restrict access to all scopes or sensitive and\n  restricted scopes until access is explicitly granted to your OAuth client ID.\n\n\n\ndisallowed_useragent\n\nThe authorization endpoint is displayed inside an embedded user-agent disallowed by Google's\n  OAuth 2.0 Policies.\n\n\n  \n    Android\n    Android developers may encounter this error message when opening authorization requests in\n      android.webkit.WebView.\n      Developers should instead use Android libraries such as\n      Google Sign-In for Android or OpenID Foundation's\n      AppAuth for Android.\n    Web developers may encounter this error when an Android app opens a general web link in an\n      embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Android App Links\n      handlers or the default browser app. The\n      Android Custom Tabs\n      library is also a supported option.\n  \n\n  \n    iOS\n    iOS and macOS developers may encounter this error when opening authorization requests in\n      WKWebView.\n      Developers should instead use iOS libraries such as\n      Google Sign-In for iOS or OpenID Foundation's\n      AppAuth for iOS.\n    Web developers may encounter this error when an iOS or macOS app opens a general web link in\n      an embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Universal Links\n      handlers or the default browser app. The\n      SFSafariViewController\n      library is also a supported option.\n  \n\n\n\n\norg_internal\n\nThe OAuth client ID in the request is part of a project limiting access to Google Accounts in a\n  specific\n  \n    Google Cloud Organization.\n  For more information about this configuration option see the\n  User type\n  section in the Setting up your OAuth consent screen help article.\n\n\n\n\n\n\n  invalid_client\n\n  The OAuth client secret is incorrect. Review the\n    OAuth client\n    configuration, including the client ID and secret used for this request.\n\n\n\n\n  invalid_grant\n\n  \n    \n\n    \n    When refreshing an access token or using\n      incremental authorization, the token may have expired or has\n      been invalidated.\n    \n\n    \n\n    Authenticate the user again and ask for user consent to obtain new tokens. If you are continuing\n    to see this error, ensure that your application has been configured correctly and that you are\n    using the correct tokens and parameters in your request. Otherwise, the user account may have\n    been deleted or disabled.\n\n\n\n\n\nredirect_uri_mismatch\n\nThe redirect_uri passed in the authorization request does not match an authorized\n  redirect URI for the OAuth client ID. Review authorized redirect URIs in the\n  Google API Console Credentials page.\n\n\n\n\n\nThe redirect_uri parameter may refer to the OAuth out-of-band (OOB) flow that has\n  been deprecated and is no longer supported. Refer to the\n  migration guide to update your\n  integration.\n\n\n\n  invalid_request\n  There was something wrong with the request you made. This could be due to a number of reasons:\n  \n\n    \n      The request was not properly formatted\n      The request was missing required parameters\n       The request uses an authorization method that Google doesn't support. Verify your OAuth\n        integration uses a recommended integration method\n        \n    \n  \n\n\n     \n\n    \n\n    \n\n    Step 4: Handle the OAuth 2.0 server response\n\n    Important:\n      Before handling the OAuth 2.0 response on the server, you should confirm that the\n      state received from Google matches the state sent in the\n      authorization request. This verification helps to ensure that the user, not a malicious\n      script, is making the request and reduces the risk of\n      CSRF attacks.\n    \n\n    The OAuth 2.0 server responds to your application's access request by using the URL specified\n      in the request.\n\n    If the user approves the access request, then the response contains an authorization code. If\n      the user does not approve the request, the response contains an error message. The\n      authorization code or error message that is returned to the web server appears on the query\n      string, as shown below:\n\n    An error response:\n\n    https://oauth2.example.com/auth?error=access_denied\n\n    An authorization code response:\n\n    https://oauth2.example.com/auth?code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7\n\n    Important: If your response endpoint renders an\n      HTML page, any resources on that page will be able to see the authorization code in the URL.\n      Scripts can read the URL directly, and the URL in the Referer HTTP header may be\n      sent to any or all resources on the page.\n\n      Carefully consider whether you want to send authorization credentials to all resources on\n        that page (especially third-party scripts such as social plugins and analytics). To avoid\n        this issue, we recommend that the server first handle the request, then redirect to another\n        URL that doesn't include the response parameters.\n\n    Sample OAuth 2.0 server response\n\n    \nYou can test this flow by clicking on the following sample URL, which requests\nread-only access to view metadata for files in your Google Drive:\n\n\n    https://accounts.google.com/o/oauth2/v2/auth?\n scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly&\n access_type=offline&\n include_granted_scopes=true&\n response_type=code&\n state=state_parameter_passthrough_value&\n redirect_uri=https%3A//oauth2.example.com/code&\n client_id=client_id\n\n    After completing the OAuth 2.0 flow, you should be redirected to\n      http://localhost/oauth2callback, which will likely yield a\n      404 NOT FOUND error unless your local machine serves a file at that address. The\n      next step provides more detail about the information returned in the URI when the user is\n      redirected back to your application.\n\n     \n\n    Step 5: Exchange authorization code for refresh and access\n      tokens\n\n    After the web server receives the authorization code, it can exchange the authorization code\n      for an access token.\n\n    \n\n    \n\n    \n\n    \n\n      \n\n        PHP\n\n        To exchange an authorization code for an access token, use the authenticate\n  method:\n\n$client->authenticate($_GET['code']);\n\nYou can retrieve the access token with the getAccessToken method:\n\n$access_token = $client->getAccessToken();\n\n      \n\n      \n\n        Python\n\n        On your callback page, use the google-auth library to verify the authorization\n  server response. Then, use the flow.fetch_token method to exchange the authorization\n  code in that response for an access token:\n\nstate = flask.session['state']\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'],\n    state=state)\nflow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\nauthorization_response = flask.request.url\nflow.fetch_token(authorization_response=authorization_response)\n\n# Store the credentials in the session.\n# ACTION ITEM for developers:\n#     Store user's access and refresh tokens in your data store if\n#     incorporating this code into your real app.\ncredentials = flow.credentials\nflask.session['credentials'] = {\n    'token': credentials.token,\n    'refresh_token': credentials.refresh_token,\n    'token_uri': credentials.token_uri,\n    'client_id': credentials.client_id,\n    'client_secret': credentials.client_secret,\n    'scopes': credentials.scopes}\n\n      \n\n      \n\n        Ruby\n\n        On your callback page, use the googleauth library to verify the authorization server\n  response. Use the authorizer.handle_auth_callback_deferred method to save the\n  authorization code and redirect back to the URL that originally requested authorization. This\n  defers the exchange of the code by temporarily stashing the results in the user's session.\n\n  target_url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(request)\n  redirect target_url\n\n      \n\n      \n\n        Node.js\n\n        To exchange an authorization code for an access token, use the getToken\n  method:\n\nconst url = require('url');\n\n// Receive the callback from Google's OAuth 2.0 server.\napp.get('/oauth2callback', async (req, res) => {\n  let q = url.parse(req.url, true).query;\n\n  if (q.error) { // An error response e.g. error=access_denied\n    console.log('Error:' + q.error);\n  } else if (q.state !== req.session.state) { //check state value\n    console.log('State mismatch. Possible CSRF attack');\n    res.end('State mismatch. Possible CSRF attack');\n  } else { // Get access and refresh tokens (if access_type is offline)\n\n    let { tokens } = await oauth2Client.getToken(q.code);\n    oauth2Client.setCredentials(tokens);\n});\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo exchange an authorization code for an access token, call the\n  https://oauth2.googleapis.com/token endpoint and set the following parameters:\n\n\n  \n    \n      Fields\n    \n  \n  \n    \n      client_id\n      The client ID obtained from the API Console\n        Credentials page.\n    \n\n    \n      client_secret\n      The client secret obtained from the API Console\n        Credentials page.\n    \n\n    \n      code\n      The authorization code returned from the initial request.\n    \n\n    \n\n    \n      grant_type\n      As defined in the OAuth 2.0\n        specification, this field's value must be set to authorization_code.\n    \n    \n      redirect_uri\n      One of the redirect URIs listed for your project in the\n        API Console\n        Credentials page for the given\n        client_id.\n    \n  \n\n\nThe following snippet shows a sample request:\n\nPOST /token HTTP/1.1\nHost: oauth2.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\ncode=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7&\nclient_id=your_client_id&\nclient_secret=your_client_secret&\nredirect_uri=https%3A//oauth2.example.com/code&\ngrant_type=authorization_code\n\nGoogle responds to this request by returning a JSON object that contains a short-lived access\n  token and a refresh token.\n\n  Note that the refresh token is only returned if your application set the access_type\n  parameter to offline in the initial request to Google's\n  authorization server.\n\n\n\nThe response contains the following fields:\n\n\n  \n    \n      Fields\n    \n  \n  \n    \n      access_token\n      The token that your application sends to authorize a Google API request.\n    \n    \n      expires_in\n      The remaining lifetime of the access token in seconds.\n    \n\n    \n    \n      refresh_token\n      A token that you can use to obtain a new access token. Refresh tokens are valid until the\n        user revokes access.\n    \n        Again, this field is only present in this response if you set the access_type\n        parameter to offline in the initial request to Google's authorization server.\n    \n      \n    \n    \n      scope\n      The scopes of access granted by the access_token expressed as a list of\n        space-delimited, case-sensitive strings.\n    \n    \n      token_type\n      The type of token returned. At this time, this field's value is always set to\n        Bearer.\n    \n  \n\n\nImportant: Your application should store both tokens in a secure,\n  long-lived location that is accessible between different invocations of your application. The\n  refresh token enables your application to obtain a new access token if the one that you have\n  expires. As such, if your application loses the refresh token, the user will need to repeat the\n  OAuth 2.0 consent flow so that your application can obtain a new refresh token.\n\n\n\nThe following snippet shows a sample response:\n\n{\n  \"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\n  \"expires_in\": 3920,\n  \"token_type\": \"Bearer\",\n  \"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\n  \"refresh_token\": \"1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI\"\n}\n\nNote: Your application should ignore any unrecognized fields included in\n  the response.\n\n      \n\n    \n\n    \n\n    \n\n    \n    Errors\n\n    When exchanging the authorization code for an access token you may encounter the following\n      error instead of the expected response. Common error codes and suggested resolutions are\n      listed below.\n\n      \n        invalid_grant\n\n        The supplied authorization code is invalid or in the wrong format. Request a new code by\n          restarting the OAuth process to prompt the user for consent\n          again.\n      \n    \n\n     \n\n    \n\n\n    \n\n    Calling Google APIs\n\n    \n     \n\n    \n\n      \n\n        PHP\n\n        Use the access token to call Google APIs by completing the following steps:\n\n\n  If you need to apply an access token to a new Google\\Client object — for\n    example, if you stored the access token in a user session — use the\n    setAccessToken method:\n\n    $client->setAccessToken($access_token);\n  \n  Build a service object for the API that you want to call. You build a service object by\n    providing an authorized Google\\Client object to the constructor for the API you\n    want to call. \nFor example, to call the Drive API:\n\n    $drive = new Google\\Service\\Drive($client);\n  \n  Make requests to the API service using the\n    interface provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    $files = $drive->files->listFiles(array())->getItems();\n  \n\n\n      \n\n      \n\n        Python\n\n        After obtaining an access token, your application can use that token to authorize API requests on\n  behalf of a given user account or service account. Use the user-specific authorization credentials\n  to build a service object for the API that you want to call, and then use that object to make\n  authorized API requests.\n\n\n  Build a service object for the API that you want to call. You build a service object by\n    calling the googleapiclient.discovery library's build method with the\n    name and version of the API and the user credentials:\n    \nFor example, to call version 3 of the Drive API:\n\n    from googleapiclient.discovery import build\n\ndrive = build('drive', 'v2', credentials=credentials)\n  \n  Make requests to the API service using the\n    interface provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    files = drive.files().list().execute()\n  \n\n\n      \n\n      \n\n        Ruby\n\n        After obtaining an access token, your application can use that token to make API requests on\n  behalf of a given user account or service account. Use the user-specific authorization credentials\n  to build a service object for the API that you want to call, and then use that object to make\n  authorized API requests.\n\n\n  Build a service object for the API that you want to call.\n    \nFor example, to call version 3 of the Drive API:\n\n    drive = Google::Apis::DriveV3::DriveService.new\n  \n  Set the credentials on the service:\n    drive.authorization = credentials\n  \n  Make requests to the API service using the\n    interface\n      provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    \n    files = drive.list_files\n    \n  \n\n\nAlternately, authorization can be provided on a per-method basis by supplying the\n  options parameter to a method:\n\n\nfiles = drive.list_files(options: { authorization: credentials })\n\n\n      \n\n      \n\n        Node.js\n\n        After obtaining an access token and setting it to the OAuth2 object, use the object\n  to call Google APIs. Your application can use that token to authorize API requests on behalf of\n  a given user account or service account. Build a service object for the API that you want to call.\n\nconst { google } = require('googleapis');\n\n// Example of using Google Drive API to list filenames in user's Drive.\nconst drive = google.drive('v3');\ndrive.files.list({\n  auth: oauth2Client,\n  pageSize: 10,\n  fields: 'nextPageToken, files(id, name)',\n}, (err1, res1) => {\n  if (err1) return console.log('The API returned an error: ' + err1);\n  const files = res1.data.files;\n  if (files.length) {\n    console.log('Files:');\n    files.map((file) => {\n      console.log(`${file.name} (${file.id})`);\n    });\n  } else {\n    console.log('No files found.');\n  }\n});\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter your application obtains an access token, you can use the token to make calls to a Google\n  API on behalf of a given\n  user account if the scope(s) of access required by the API have been granted. To do this, include\n  the access token in a request to the API by including either an access_token query\n  parameter or an Authorization HTTP header Bearer value. When possible,\n  the HTTP header is preferable, because query strings tend to be visible in server logs. In most\n  cases you can use a client library to set up your calls to Google APIs (for example, when\n  calling the Drive Files API).\n\n\n\nYou can try out all the Google APIs and view their scopes at the\n  OAuth 2.0 Playground.\n\nHTTP GET examples\n\nA call to the\n  \n    drive.files\n  endpoint (the Drive Files API) using the Authorization: Bearer HTTP\n  header might look like the following. Note that you need to specify your own access token:\n\nGET /drive/v2/files HTTP/1.1\nHost: www.googleapis.com\nAuthorization: Bearer access_token\n\nHere is a call to the same API for the authenticated user using the access_token\n  query string parameter:\n\nGET https://www.googleapis.com/drive/v2/files?access_token=access_token\n\ncurl examples\n\nYou can test these commands with the curl command-line application. Here's an\n  example that uses the HTTP header option (preferred):\n\ncurl -H \"Authorization: Bearer access_token\" https://www.googleapis.com/drive/v2/files\n\nOr, alternatively, the query string parameter option:\n\ncurl https://www.googleapis.com/drive/v2/files?access_token=access_token\n\n      \n\n    \n\n     \n\n     \n     \n\n\n    \n\n    Complete example\n\n    \nThe following example prints a JSON-formatted list of files in a user's Google Drive after the\n  user authenticates and gives consent for the application to access the user's Drive metadata.\n\n\n    \n     \n\n    \n\n      \n\n        PHP\n\n        To run this example:\n\n\n  In the API Console, add the URL of the local machine to the\n    list of redirect URLs. For example, add http://localhost:8080.\n  Create a new directory and change to it. For example:\n    mkdir ~/php-oauth2-example\ncd ~/php-oauth2-example\n  Install the Google API Client\n    Library for PHP using Composer:\n      composer require google/apiclient:^2.10\n  Create the files index.php and oauth2callback.php with the content\n    below.\n  Run the example with a web server configured to serve PHP. If you use PHP 5.6 or newer, you\n    can use PHP's built-in test web server:\n      php -S localhost:8080 ~/php-oauth2-example\n\n\nindex.php\n\n<?php\nrequire_once __DIR__.'/vendor/autoload.php';\n\nsession_start();\n\n$client = new Google\\Client();\n$client->setAuthConfig('client_secrets.json');\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\nif (isset($_SESSION['access_token']) && $_SESSION['access_token']) {\n  $client->setAccessToken($_SESSION['access_token']);\n  $drive = new Google\\Service\\Drive($client);\n  $files = $drive->files->listFiles(array())->getItems();\n  echo json_encode($files);\n} else {\n  $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php';\n  header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL));\n}\n\noauth2callback.php\n\n<?php\nrequire_once __DIR__.'/vendor/autoload.php';\n\nsession_start();\n\n$client = new Google\\Client();\n$client->setAuthConfigFile('client_secrets.json');\n$client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php');\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\nif (! isset($_GET['code'])) {\n  // Generate and set state value\n  $state = bin2hex(random_bytes(16));\n  $client->setState($state);\n  $_SESSION['state'] = $state;\n\n  $auth_url = $client->createAuthUrl();\n  header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL));\n} else {\n  // Check the state value\n  if (!isset($_GET['state']) || $_GET['state'] !== $_SESSION['state']) {\n    die('State mismatch. Possible CSRF attack.');\n  }\n  $client->authenticate($_GET['code']);\n  $_SESSION['access_token'] = $client->getAccessToken();\n  $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/';\n  header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL));\n}\n\n      \n\n      \n\n        Python\n\n        This example uses the Flask framework. It\n  runs a web application at http://localhost:8080 that lets you test the OAuth 2.0\n  flow. If you go to that URL, you should see four links:\n\n\n  Test an API request: This link points to a page that tries to execute a sample API\n    request. If necessary, it starts the authorization flow. If successful, the page displays the\n    API response.\n  Test the auth flow directly: This link points to a page that tries to send the user\n    through the authorization flow. The app requests permission to\n    submit authorized API requests on the user's behalf.\n  Revoke current credentials: This link points to a page that \n    revokes permissions that the user has already granted to the application.\n  Clear Flask session credentials: This link clears authorization credentials that are\n    stored in the Flask session. This lets you see what would happen if a user who had already\n    granted permission to your app tried to execute an API request in a new session. It also lets\n    you see the API response your app would get if a user had revoked permissions granted to your\n    app, and your app still tried to authorize a request with a revoked access token.\n\n\nNote: To run this code locally, you must have followed the directions in\n  the prerequisites section, including setting\n  http://localhost:8080 as a valid redirect URI for your credentials and downloading\n  the client_secret.json file for those credentials to your working directory.\n\n# -*- coding: utf-8 -*-\n\nimport os\nimport flask\nimport requests\n\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\nimport googleapiclient.discovery\n\n# This variable specifies the name of a file that contains the OAuth 2.0\n# information for this application, including its client_id and client_secret.\nCLIENT_SECRETS_FILE = \"client_secret.json\"\n\n# This OAuth 2.0 access scope allows for full read/write access to the\n# authenticated user's account and requires requests to use an SSL connection.\nSCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly']\nAPI_SERVICE_NAME = 'drive'\nAPI_VERSION = 'v2'\n\napp = flask.Flask(__name__)\n# Note: A secret key is included in the sample so that it works.\n# If you use this code in your application, replace this with a truly secret\n# key. See https://flask.palletsprojects.com/quickstart/#sessions.\napp.secret_key = 'REPLACE ME - this value is here as a placeholder.'\n\n\n@app.route('/')\ndef index():\n  return print_index_table()\n\n\n@app.route('/test')\ndef test_api_request():\n  if 'credentials' not in flask.session:\n    return flask.redirect('authorize')\n\n  # Load credentials from the session.\n  credentials = google.oauth2.credentials.Credentials(\n      **flask.session['credentials'])\n\n  drive = googleapiclient.discovery.build(\n      API_SERVICE_NAME, API_VERSION, credentials=credentials)\n\n  files = drive.files().list().execute()\n\n  # Save credentials back to session in case access token was refreshed.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  flask.session['credentials'] = credentials_to_dict(credentials)\n\n  return flask.jsonify(**files)\n\n\n@app.route('/authorize')\ndef authorize():\n  # Create flow instance to manage the OAuth 2.0 Authorization Grant Flow steps.\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES)\n\n  # The URI created here must exactly match one of the authorized redirect URIs\n  # for the OAuth 2.0 client, which you configured in the API Console. If this\n  # value doesn't match an authorized URI, you will get a 'redirect_uri_mismatch'\n  # error.\n  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\n  authorization_url, state = flow.authorization_url(\n      # Enable offline access so that you can refresh an access token without\n      # re-prompting the user for permission. Recommended for web server apps.\n      access_type='offline',\n      # Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes='true')\n\n  # Store the state so the callback can verify the auth server response.\n  flask.session['state'] = state\n\n  return flask.redirect(authorization_url)\n\n\n@app.route('/oauth2callback')\ndef oauth2callback():\n  # Specify the state when creating the flow in the callback so that it can\n  # verified in the authorization server response.\n  state = flask.session['state']\n\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)\n  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\n  # Use the authorization server's response to fetch the OAuth 2.0 tokens.\n  authorization_response = flask.request.url\n  flow.fetch_token(authorization_response=authorization_response)\n\n  # Store credentials in the session.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  credentials = flow.credentials\n  flask.session['credentials'] = credentials_to_dict(credentials)\n\n  return flask.redirect(flask.url_for('test_api_request'))\n\n\n@app.route('/revoke')\ndef revoke():\n  if 'credentials' not in flask.session:\n    return ('You need to <a href=\"/authorize\">authorize</a> before ' +\n            'testing the code to revoke credentials.')\n\n  credentials = google.oauth2.credentials.Credentials(\n    **flask.session['credentials'])\n\n  revoke = requests.post('https://oauth2.googleapis.com/revoke',\n      params={'token': credentials.token},\n      headers = {'content-type': 'application/x-www-form-urlencoded'})\n\n  status_code = getattr(revoke, 'status_code')\n  if status_code == 200:\n    return('Credentials successfully revoked.' + print_index_table())\n  else:\n    return('An error occurred.' + print_index_table())\n\n\n@app.route('/clear')\ndef clear_credentials():\n  if 'credentials' in flask.session:\n    del flask.session['credentials']\n  return ('Credentials have been cleared.<br><br>' +\n          print_index_table())\n\n\ndef credentials_to_dict(credentials):\n  return {'token': credentials.token,\n          'refresh_token': credentials.refresh_token,\n          'token_uri': credentials.token_uri,\n          'client_id': credentials.client_id,\n          'client_secret': credentials.client_secret,\n          'scopes': credentials.scopes}\n\ndef print_index_table():\n  return ('<table>' +\n          '<tr><td><a href=\"/test\">Test an API request</a></td>' +\n          '<td>Submit an API request and see a formatted JSON response. ' +\n          '    Go through the authorization flow if there are no stored ' +\n          '    credentials for the user.</td></tr>' +\n          '<tr><td><a href=\"/authorize\">Test the auth flow directly</a></td>' +\n          '<td>Go directly to the authorization flow. If there are stored ' +\n          '    credentials, you still might not be prompted to reauthorize ' +\n          '    the application.</td></tr>' +\n          '<tr><td><a href=\"/revoke\">Revoke current credentials</a></td>' +\n          '<td>Revoke the access token associated with the current user ' +\n          '    session. After revoking credentials, if you go to the test ' +\n          '    page, you should see an <code>invalid_grant</code> error.' +\n          '</td></tr>' +\n          '<tr><td><a href=\"/clear\">Clear Flask session credentials</a></td>' +\n          '<td>Clear the access token currently stored in the user session. ' +\n          '    After clearing the token, if you <a href=\"/test\">test the ' +\n          '    API request</a> again, you should go back to the auth flow.' +\n          '</td></tr></table>')\n\n\nif __name__ == '__main__':\n  # When running locally, disable OAuthlib's HTTPs verification.\n  # ACTION ITEM for developers:\n  #     When running in production *do not* leave this option enabled.\n  os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n  # Specify a hostname and port that are set as a valid redirect URI\n  # for your API project in the Google API Console.\n  app.run('localhost', 8080, debug=True)\n\n      \n\n      \n\n        Ruby\n\n        This example uses the Sinatra framework.\n\nrequire 'google/apis/drive_v3'\nrequire 'sinatra'\nrequire 'googleauth'\nrequire 'googleauth/stores/redis_token_store'\n\nconfigure do\n  enable :sessions\n\n  set :client_id, Google::Auth::ClientId.from_file('/path/to/client_secret.json')\n  set :scope, Google::Apis::DriveV3::AUTH_DRIVE_METADATA_READONLY\n  set :token_store, Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\n  set :authorizer, Google::Auth::WebUserAuthorizer.new(settings.client_id, settings.scope, settings.token_store, '/oauth2callback')\nend\n\nget '/' do\n  user_id = settings.client_id.id\n  credentials = settings.authorizer.get_credentials(user_id, request)\n  if credentials.nil?\n    redirect settings.authorizer.get_authorization_url(login_hint: user_id, request: request)\n  end\n  drive = Google::Apis::DriveV3::DriveService.new\n  files = drive.list_files(options: { authorization: credentials })\n  \"<pre>#{JSON.pretty_generate(files.to_h)}</pre>\"\nend\n\nget '/oauth2callback' do\n  target_url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(request)\n  redirect target_url\nend\n\n      \n\n      \n\n        Node.js\n\n        To run this example:\n\n\n  \n    In the API Console, add the URL of the\n    local machine to the list of redirect URLs. For example, add\n    http://localhost.\n  \n  \n    Make sure you have maintenance LTS, active LTS, or current release of\n    Node.js installed.\n  \n  \n    Create a new directory and change to it. For example:\n    mkdir ~/nodejs-oauth2-example\ncd ~/nodejs-oauth2-example\n  \n  \n    Install the\n    Google API Client\n      Library\n    for Node.js using npm:\n    npm install googleapis\n  \n  \n    Create the files main.js with the content below.\n  \n  \n    Run the example:\n    node .\\main.js\n  \n\nmain.js\nconst http = require('http');\nconst https = require('https');\nconst url = require('url');\nconst { google } = require('googleapis');\nconst crypto = require('crypto');\nconst express = require('express');\nconst session = require('express-session');\n\n/**\n * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI.\n * To get these credentials for your application, visit\n * https://console.cloud.google.com/apis/credentials.\n */\nconst oauth2Client = new google.auth.OAuth2(\n  YOUR_CLIENT_ID,\n  YOUR_CLIENT_SECRET,\n  YOUR_REDIRECT_URL\n);\n\n// Access scopes for read-only Drive activity.\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly'\n];\n/* Global variable that stores user credential in this code example.\n * ACTION ITEM for developers:\n *   Store user's refresh token in your data store if\n *   incorporating this code into your real app.\n *   For more information on handling refresh tokens,\n *   see https://github.com/googleapis/google-api-nodejs-client#handling-refresh-tokens\n */\nlet userCredential = null;\n\nasync function main() {\n  const app = express();\n\n  app.use(session({\n    secret: 'your_secure_secret_key', // Replace with a strong secret\n    resave: false,\n    saveUninitialized: false,\n  }));\n\n  // Example on redirecting user to Google's OAuth 2.0 server.\n  app.get('/', async (req, res) => {\n    // Generate a secure random state value.\n    const state = crypto.randomBytes(32).toString('hex');\n    // Store state in the session\n    req.session.state = state;\n\n    // Generate a url that asks permissions for the Drive activity scope\n    const authorizationUrl = oauth2Client.generateAuthUrl({\n      // 'online' (default) or 'offline' (gets refresh_token)\n      access_type: 'offline',\n      /** Pass in the scopes array defined above.\n        * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n      scope: scopes,\n      // Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes: true,\n      // Include the state parameter to reduce the risk of CSRF attacks.\n      state: state\n    });\n\n    res.redirect(authorizationUrl);\n  });\n\n  // Receive the callback from Google's OAuth 2.0 server.\n  app.get('/oauth2callback', async (req, res) => {\n    // Handle the OAuth 2.0 server response\n    let q = url.parse(req.url, true).query;\n\n    if (q.error) { // An error response e.g. error=access_denied\n      console.log('Error:' + q.error);\n    } else if (q.state !== req.session.state) { //check state value\n      console.log('State mismatch. Possible CSRF attack');\n      res.end('State mismatch. Possible CSRF attack');\n    } else { // Get access and refresh tokens (if access_type is offline)\n      let { tokens } = await oauth2Client.getToken(q.code);\n      oauth2Client.setCredentials(tokens);\n\n      /** Save credential to the global variable in case access token was refreshed.\n        * ACTION ITEM: In a production app, you likely want to save the refresh token\n        *              in a secure persistent database instead. */\n      userCredential = tokens;\n\n      // Example of using Google Drive API to list filenames in user's Drive.\n      const drive = google.drive('v3');\n      drive.files.list({\n        auth: oauth2Client,\n        pageSize: 10,\n        fields: 'nextPageToken, files(id, name)',\n      }, (err1, res1) => {\n        if (err1) return console.log('The API returned an error: ' + err1);\n        const files = res1.data.files;\n        if (files.length) {\n          console.log('Files:');\n          files.map((file) => {\n            console.log(`${file.name} (${file.id})`);\n          });\n        } else {\n          console.log('No files found.');\n        }\n      });\n    }\n  });\n\n  // Example on revoking a token\n  app.get('/revoke', async (req, res) => {\n    // Build the string for the POST request\n    let postData = \"token=\" + userCredential.access_token;\n\n    // Options for POST request to Google's OAuth 2.0 server to revoke a token\n    let postOptions = {\n      host: 'oauth2.googleapis.com',\n      port: '443',\n      path: '/revoke',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData)\n      }\n    };\n\n    // Set up the request\n    const postReq = https.request(postOptions, function (res) {\n      res.setEncoding('utf8');\n      res.on('data', d => {\n        console.log('Response: ' + d);\n      });\n    });\n\n    postReq.on('error', error => {\n      console.log(error)\n    });\n\n    // Post the request with data\n    postReq.write(postData);\n    postReq.end();\n  });\n\n\n  const server = http.createServer(app);\n  server.listen(80);\n}\nmain().catch(console.error);\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\nThis Python example uses the Flask framework\n  and the Requests library to demonstrate the OAuth\n  2.0 web flow. We recommend using the Google API Client Library for Python for this flow. (The\n  example in the Python tab does use the client library.)\n\nimport json\n\nimport flask\nimport requests\n\n\napp = flask.Flask(__name__)\n\nCLIENT_ID = '123456789.apps.googleusercontent.com'\nCLIENT_SECRET = 'abc123'  # Read from a file or environmental variable in a real app\nSCOPE = 'https://www.googleapis.com/auth/drive.metadata.readonly'\nREDIRECT_URI = 'http://example.com/oauth2callback'\n\n\n@app.route('/')\ndef index():\n  if 'credentials' not in flask.session:\n    return flask.redirect(flask.url_for('oauth2callback'))\n  credentials = json.loads(flask.session['credentials'])\n  if credentials['expires_in'] <= 0:\n    return flask.redirect(flask.url_for('oauth2callback'))\n  else:\n    headers = {'Authorization': 'Bearer {}'.format(credentials['access_token'])}\n    req_uri = 'https://www.googleapis.com/drive/v2/files'\n    r = requests.get(req_uri, headers=headers)\n    return r.text\n\n\n@app.route('/oauth2callback')\ndef oauth2callback():\n  if 'code' not in flask.request.args:\n    state = str(uuid.uuid4())\n    flask.session['state'] = state\n    auth_uri = ('https://accounts.google.com/o/oauth2/v2/auth?response_type=code'\n                '&client_id={}&redirect_uri={}&scope={}&state={}').format(CLIENT_ID, REDIRECT_URI,\n                                                                          SCOPE, state)\n    return flask.redirect(auth_uri)\n  else:\n    if 'state' not in flask.request.args or flask.request.args['state'] != flask.session['state']:\n      return 'State mismatch. Possible CSRF attack.', 400\n\n    auth_code = flask.request.args.get('code')\n    data = {'code': auth_code,\n            'client_id': CLIENT_ID,\n            'client_secret': CLIENT_SECRET,\n            'redirect_uri': REDIRECT_URI,\n            'grant_type': 'authorization_code'}\n    r = requests.post('https://oauth2.googleapis.com/token', data=data)\n    flask.session['credentials'] = r.text\n    return flask.redirect(flask.url_for('index'))\n\n\nif __name__ == '__main__':\n  import uuid\n  app.secret_key = str(uuid.uuid4())\n  app.debug = False\n  app.run()\n\n      \n\n    \n\n     \n\n     \n     \n\n    \n\n    Redirect URI validation rules\n\n    Google applies the following validation rules to redirect URIs in order to help developers\n      keep their applications secure. Your redirect URIs must adhere to these rules. See\n      RFC 3986 section 3 for the\n      definition of domain, host, path, query, scheme and userinfo, mentioned below.\n    \n\n    \n\n    \n    \n  \n    \n      Validation rules\n    \n  \n  \n    \n      Scheme\n      \n        \n          Redirect URIs must use the HTTPS scheme, not plain HTTP. Localhost URIs (including\n          localhost IP address URIs) are exempt from this rule.\n        \n      \n    \n\n    \n      Host\n      \n        Hosts cannot be raw IP addresses. Localhost IP addresses are exempted from this rule.\n      \n    \n\n    \n      Domain\n      \n        Host TLDs\n          (Top Level Domains)\n          must belong to the public suffix list.\n        Host domains cannot be “googleusercontent.com”.\n        \n          Redirect URIs cannot contain URL shortener domains (e.g. goo.gl) unless\n            the app owns the domain. Furthermore, if an app that owns a shortener domain chooses to\n            redirect to that domain, that redirect URI must either contain\n            “/google-callback/” in its path or end with\n            “/google-callback”.\n        \n      \n    \n\n    \n      Userinfo\n      \n        \n          Redirect URIs cannot contain the userinfo subcomponent.\n        \n      \n    \n\n    \n      Path\n      \n        \n          Redirect URIs cannot contain a path traversal (also called directory backtracking),\n            which is represented by an “/..” or “\\..” or their URL\n            encoding.\n        \n      \n    \n\n    \n      Query\n      \n        \n          Redirect URIs cannot contain\n            open redirects.\n        \n      \n    \n\n    \n      Fragment\n      \n        \n          Redirect URIs cannot contain the fragment component.\n        \n      \n    \n\n    \n      Characters\n      \n        \n          Redirect URIs cannot contain certain characters including:\n        \n\n        \n          Wildcard characters ('*')\n          Non-printable ASCII characters\n          Invalid percent encodings (any percent encoding that does not follow URL-encoding\n            form of a percent sign followed by two hexadecimal digits)\n          Null characters (an encoded NULL character, e.g., %00,\n            %C0%80)\n        \n      \n    \n  \n\n\n     \n     \n\n    \n\n    Incremental authorization\n\n    In the OAuth 2.0 protocol, your app requests authorization to access resources, which are\n  identified by scopes. It is considered a best user-experience practice to request authorization\n  for resources at the time you need them. To enable that practice, Google's authorization server\n  supports incremental authorization. This feature lets you request scopes as they are needed and,\n  if the user grants permission for the new scope, returns an authorization code that may be\n  exchanged for a token containing all scopes the user has granted the project.\n\n\nFor example, an app that lets people sample music tracks and create mixes might need very few\n  resources at sign-in time, perhaps nothing more than the name of the person signing in. However,\n  saving a completed mix would require access to their Google Drive. Most people would find it\n  natural if they only were asked for access to their Google Drive at the time the app actually\n  needed it.\n\nIn this case, at sign-in time the app might request the openid and\n  profile scopes to perform basic sign-in, and then later request the\n  https://www.googleapis.com/auth/drive.file scope at the time of the first request to save a\n  mix.\n\n\n\nTo implement incremental authorization, you complete the normal flow for requesting an access\n  token but make sure that the authorization request includes previously granted scopes. This\n  approach allows your app to avoid having to manage multiple access tokens.\n\n\nThe following rules apply to an access token obtained from an incremental authorization:\n\n\n  The token can be used to access resources corresponding to any of the scopes rolled into the\n    new, combined authorization.\n  When you use the refresh token for the combined authorization to obtain an access token, the\n    access token represents the combined authorization and can be used for any of the\n    scope values included in the response.\n  The combined authorization includes all scopes that the user granted to the API project even\n    if the grants were requested from different clients. For example, if a user granted access to\n    one scope using an application's desktop client and then granted another scope to the same\n    application via a mobile client, the combined authorization would include both scopes.\n  If you revoke a token that represents a combined authorization, access to all of that\n    authorization's scopes on behalf of the associated user are revoked simultaneously.\n\n\nCaution: choosing to include granted scopes will automatically add\n  scopes previously granted by the user to your authorization request. A warning or error page may\n  be displayed if your app is not currently approved to request all scopes that may be returned in\n  the response. See\n  Unverified apps for\n  more information.\n\n\n\n    \n    \n\n    The language-specific code samples in Step 1: Set authorization\n      parameters and the sample HTTP/REST redirect URL in Step 2:\n      Redirect to Google's OAuth 2.0 server all use incremental authorization. The code samples\n      below also show the code that you need to add to use incremental authorization.\n\n    \n\n      \n\n        PHP\n\n        $client->setIncludeGrantedScopes(true);\n\n      \n\n      \n\n        Python\n\n        In Python, set the include_granted_scopes keyword argument to true to\n  ensure that an authorization request includes previously granted scopes. It is very possible that\n  include_granted_scopes will not be the only keyword argument that you set, as\n  shown in the example below.\n\nauthorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')\n\n      \n\n      \n\n        Ruby\n\n        auth_client.update!(\n  :additional_parameters => {\"include_granted_scopes\" => \"true\"}\n)\n\n      \n\n      \n\n        Node.js\n\n        const authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});\n\n      \n\n      \n\n        HTTP/REST\n\n        \n        \nGET https://accounts.google.com/o/oauth2/v2/auth?\n  client_id=your_client_id&\n  response_type=code&\n  state=state_parameter_passthrough_value&\n  scope=https%3A//www.googleapis.com/auth/drive.file&\n  redirect_uri=https%3A//oauth2.example.com/code&\n  prompt=consent&\n  include_granted_scopes=true\n\n\n      \n\n    \n\n    \n\n     \n     \n\n    \n\n    Refreshing an access token (offline access)\n\n    \n\nAccess tokens periodically expire and become invalid credentials for a related API request. You\n  can refresh an access token without prompting the user for permission (including when the user is\n  not present) if you requested offline access to the scopes associated with the token.\n\n    \n    \n      \nIf you use a Google API Client Library, the client object refreshes\nthe access token as needed as long as you configure that object for offline access.\n\n      If you are not using a client library, you need to set the access_type HTTP\n        query parameter to offline when redirecting the user to\n        Google's OAuth 2.0 server. In that case, Google's authorization server returns a\n        refresh token when you exchange an authorization\n        code for an access token. Then, if the access token expires (or at any other time), you\n        can use a refresh token to obtain a new access token.\n    \n    \n\n    Requesting offline access is a requirement for any application that needs to access a Google\n      API when the user is not present. For example, an app that performs backup services or\n      executes actions at predetermined times needs to be able to refresh its access token when the\n      user is not present. The default style of access is called online.\n\n    Server-side web applications, installed applications, and devices all obtain refresh tokens\n      during the authorization process. Refresh tokens are not typically used in client-side\n      (JavaScript) web applications.\n\n    \n     \n\n    \n\n      \n\n        PHP\n\n        If your application needs offline access to a Google API, set the API client's access type to\n  offline:\n\n$client->setAccessType(\"offline\");\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\n      \n\n      \n\n        Python\n\n        In Python, set the access_type keyword argument to offline to ensure\n  that you will be able to refresh the access token without having to re-prompt the user for\n  permission. It is very possible that access_type will not be the only keyword\n  argument that you set, as shown in the example below.\n\nauthorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\n      \n\n      \n\n        Ruby\n\n        If your application needs offline access to a Google API, set the API client's access type to\n  offline:\n\nauth_client.update!(\n  :additional_parameters => {\"access_type\" => \"offline\"}\n)\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\n      \n\n      \n\n        Node.js\n\n        If your application needs offline access to a Google API, set the API client's access type to\n  offline:\n\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\nAccess tokens expire. This library will automatically use a refresh token to obtain a new access\n  token if it is about to expire. An easy way to make sure you always store the most recent tokens\n  is to use the tokens event:\noauth2Client.on('tokens', (tokens) => {\n  if (tokens.refresh_token) {\n    // store the refresh_token in your secure persistent database\n    console.log(tokens.refresh_token);\n  }\n  console.log(tokens.access_token);\n});\nThis tokens event only occurs in the first authorization, and you need to have set your\n  access_type to offline when calling the generateAuthUrl\n  method to receive the refresh token. If you have already given your app the requisiste permissions\n  without setting the appropriate constraints for receiving a refresh token, you will need to\n  re-authorize the application to receive a fresh refresh token.\n\nTo set the refresh_token at a later time, you can use the setCredentials method:\n\noauth2Client.setCredentials({\n  refresh_token: `STORED_REFRESH_TOKEN`\n});\n\n  Once the client has a refresh token, access tokens will be acquired and refreshed automatically\n  in the next call to the API.\n\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo refresh an access token, your application sends an HTTPS POST\n  request to Google's authorization server (https://oauth2.googleapis.com/token) that\n  includes the following parameters:\n\n\n  \n    \n      Fields\n    \n  \n  \n    \n      client_id\n      The client ID obtained from the API Console.\n    \n    \n      client_secret\n      The client secret obtained from the API Console.\n        \n      \n    \n    \n      grant_type\n      As\n        defined in the\n          OAuth 2.0 specification,\n        this field's value must be set to refresh_token.\n    \n    \n      refresh_token\n      The refresh token returned from the authorization code exchange.\n    \n  \n\n\nThe following snippet shows a sample request:\n\nPOST /token HTTP/1.1\nHost: oauth2.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\nclient_id=your_client_id&\nclient_secret=your_client_secret&\nrefresh_token=refresh_token&\ngrant_type=refresh_token\n\nAs long as the user has not revoked the access granted to the application, the token server\n  returns a JSON object that contains a new access token. The following snippet shows a sample\n  response:\n\n{\n  \"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\n  \"expires_in\": 3920,\n  \"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\n  \"token_type\": \"Bearer\"\n}\n\nNote that there are limits on the number of refresh tokens that will be issued; one limit per\n  client/user combination, and another per user across all clients. You should save refresh tokens\n  in long-term storage and continue to use them as long as they remain valid. If your application\n  requests too many refresh tokens, it may run into these limits, in which case older refresh tokens\n  will stop working.\n\n      \n\n    \n\n    \n\n    \n\n    Revoking a token\n\nIn some cases a user may wish to revoke access given to an application. A user can revoke access\n  by visiting \n  Account Settings. See the\n  Remove\n    site or app access section of the Third-party sites & apps with access to your account\n  support document for more information.\n\nIt is also possible for an application to programmatically revoke the access given to it.\n  Programmatic revocation is important in instances where a user unsubscribes, removes an\n  application, or the API resources required by an app have significantly changed. In other words,\n  part of the removal process can include an API request to ensure the permissions previously\n  granted to the application are removed.\n\n    \n\n    \n\n    \n\n      \n\n        PHP\n\n        To programmatically revoke a token, call revokeToken():\n\n$client->revokeToken();\n\n      \n\n      \n\n        Python\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo programmatically revoke a token, make a request to\n  https://oauth2.googleapis.com/revoke that includes the token as a parameter and sets the\n  Content-Type header:\n\nrequests.post('https://oauth2.googleapis.com/revoke',\n    params={'token': credentials.token},\n    headers = {'content-type': 'application/x-www-form-urlencoded'})\n\n      \n\n      \n\n        Ruby\n\n        To programmatically revoke a token, make an HTTP request to the oauth2.revoke\n  endpoint:\n\nuri = URI('https://oauth2.googleapis.com/revoke')\nresponse = Net::HTTP.post_form(uri, 'token' => auth_client.access_token)\n\nThe token can be an access token or a refresh token. If the token is an access token and it has\n  a corresponding refresh token, the refresh token will also be revoked.\n\nIf the revocation is successfully processed, then the status code of the response is\n  200. For error conditions, a status code 400 is returned along with an\n  error code.\n\n      \n\n      \n\n        Node.js\n\n        To programmatically revoke a token, make an HTTPS POST request to /revoke\n  endpoint:\n\nconst https = require('https');\n\n// Build the string for the POST request\nlet postData = \"token=\" + userCredential.access_token;\n\n// Options for POST request to Google's OAuth 2.0 server to revoke a token\nlet postOptions = {\n  host: 'oauth2.googleapis.com',\n  port: '443',\n  path: '/revoke',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n};\n\n// Set up the request\nconst postReq = https.request(postOptions, function (res) {\n  res.setEncoding('utf8');\n  res.on('data', d => {\n    console.log('Response: ' + d);\n  });\n});\n\npostReq.on('error', error => {\n  console.log(error)\n});\n\n// Post the request with data\npostReq.write(postData);\npostReq.end();\n\nThe token parameter can be an access token or a refresh token. If the token is an access token and it has\n  a corresponding refresh token, the refresh token will also be revoked.\n\nIf the revocation is successfully processed, then the status code of the response is\n  200. For error conditions, a status code 400 is returned along with an\n  error code.\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo programmatically revoke a token, your application makes a request to\nhttps://oauth2.googleapis.com/revoke and includes the token as a parameter:\n\ncurl -d -X -POST --header \"Content-type:application/x-www-form-urlencoded\" \\\n        https://oauth2.googleapis.com/revoke?token={token}\n\nThe token can be an access token or a refresh token. If the token is an access token and it has a\n  corresponding refresh token, the refresh token will also be revoked.\n\n\n\nIf the revocation is successfully processed, then the HTTP status code of the response is\n  200. For error conditions, an HTTP status code 400 is returned along\n  with an error code.\n\n\n\n      \n\n    \n\n    \n\n    \n\n    Note: Following a successful revocation response, it might take some\n  time before the revocation has full effect.\n\n    \n\n    \n      Implementing Cross-Account Protection\n\n      \n  An additional step you should take to protect your users' accounts is implementing Cross-Account\n  Protection by utilizing Google's Cross-Account Protection Service. This service lets you\n  subscribe to security event notifications which provide information to your application about\n  major changes to the user account. You can then use the information to take action depending on\n  how you decide to respond to events.\n\n\n  Some examples of the event types sent to your app by Google's Cross-Account Protection Service are:\n\n\n  \n    https://schemas.openid.net/secevent/risc/event-type/sessions-revoked\n  \n  \n    https://schemas.openid.net/secevent/oauth/event-type/token-revoked\n  \n  \n    https://schemas.openid.net/secevent/risc/event-type/account-disabled\n  \n\n\n  See the\n  \n    Protect user accounts with Cross-Account Protection page\n  \n  for more information on how to implement Cross Account Protection and for the full list of available events.\n\n    \n  \n  \n\n  \n\n      \n    \n\n  \n  \n    \n    Send feedback\n  \n  \n",
            "sectionWordCount": 10460
          },
          {
            "sectionTitle": "Client libraries",
            "text": "The language-specific examples on this page use\n   Google API Client Libraries to implement\n   OAuth 2.0 authorization. To run the code samples, you must first install the\n   client library for your language.When you use a Google API Client Library to handle your application's OAuth 2.0 flow, the client\n  library performs many actions that the application would otherwise need to handle on its own. For\n  example, it determines when the application can use or refresh stored access tokens as well as\n  when the application must reacquire consent. The client library also generates correct redirect\n  URLs and helps to implement redirect handlers that exchange authorization codes for access tokens.Google API Client Libraries for server-side applications are available for the following languages:\n  Go\n  Java\n  .NET\n  Node.js\n  PHP\n  Python\n  Ruby\nImportant: The Google API client\n  library for JavaScript and Sign In With Google are\n  only intended to handle OAuth 2.0 in the user's browser. If you want to use JavaScript on the\n  server-side to manage OAuth 2.0 interactions with Google, consider using the\n  Node.js library on your back-end platform.",
            "sectionWordCount": 174
          },
          {
            "sectionTitle": "Prerequisites",
            "text": "",
            "sectionWordCount": 0
          },
          {
            "sectionTitle": "Enable APIs for your project",
            "text": "Any application that calls Google APIs needs to enable those APIs in the\n  API Console.To enable an API for your project:\n  Open the API Library in the\n    Google API Console.\n  If prompted, select a project, or create a new one.\n\n  The API Library lists all available APIs, grouped by product\n    family and popularity. If the API you want to enable isn't visible in the list, use search to\n    find it, or click View All in the product family it belongs to.\n  Select the API you want to enable, then click the Enable button.\n  If prompted, enable billing.\n  If prompted, read and accept the API's Terms of Service.\n\n",
            "sectionWordCount": 107
          },
          {
            "sectionTitle": "Create authorization credentials",
            "text": "Any application that uses OAuth 2.0 to access Google APIs must have authorization credentials\n  that identify the application to Google's OAuth 2.0 server. The following steps explain how to\n  create credentials for your project. Your applications can then use the credentials to access APIs\n  that you have enabled for that project.\n      Go to the Credentials page.\n      Click Create credentials > OAuth client ID.\n      Select the Web application application type.\n      Fill in the form and click Create. Applications that use languages and frameworks\n        like PHP, Java, Python, Ruby, and .NET must specify authorized redirect URIs. The\n        redirect URIs are the endpoints to which the OAuth 2.0 server can send responses. These\n        endpoints must adhere to Google’s validation rules.\n        For testing, you can specify URIs that refer to the local machine, such as\n          http://localhost:8080. With that in mind, please note that all of the\n          examples in this document use http://localhost:8080 as the redirect URI.\n        We recommend that you design your app's auth endpoints so\n          that your application does not expose authorization codes to other resources on the\n          page.\n    After creating your credentials, download the client_secret.json file from the\n      API Console. Securely store the file in a location that only\n      your application can access.Important: Do not store the client_secret.json file in a\n      publicly-accessible location. In addition, if you share the source code to your\n      application — for example, on GitHub — store the client_secret.json file\n      outside of your source tree to avoid inadvertently sharing your client credentials.",
            "sectionWordCount": 244
          },
          {
            "sectionTitle": "Identify access scopes",
            "text": "Scopes enable your application to only request access to the resources that it needs while also\n  enabling users to control the amount of access that they grant to your application. Thus, there\n  may be an inverse relationship between the number of scopes requested and the likelihood of\n  obtaining user consent.Before you start implementing OAuth 2.0 authorization, we recommend that you identify the scopes\n  that your app will need permission to access.We also recommend that your application request access to authorization scopes via an\n  incremental authorization process, in which your application\n  requests access to user data in context. This best practice helps users to more easily understand\n  why your application needs the access it is requesting.The OAuth 2.0 API Scopes document contains a full\n  list of scopes that you might use to access Google APIs.If your public application uses scopes that permit access to\n  certain user data, it must complete a verification process. If you see unverified\n  app on the screen when testing your application, you must submit a\n  verification request to remove it. Find out more about\n  unverified apps\n  and get answers to \n  frequently asked questions about app verification in the Help Center.\n",
            "sectionWordCount": 193
          },
          {
            "sectionTitle": "Language-specific requirements",
            "text": "To run any of the code samples in this document, you'll need a Google account, access to the\n      Internet, and a web browser. If you are using one of the API client libraries, also see the\n      language-specific requirements below.\n\n      \n\n        PHP\n\n        To run the PHP code samples in this document, you'll need:\n\n\n  PHP 5.6 or greater with the command-line interface (CLI) and JSON extension installed.\n  The Composer dependency management tool.\n  \n    The Google APIs Client Library for PHP:\n    composer require google/apiclient:^2.10\n  \n\n\n      \n\n      \n\n        Python\n\n        To run the Python code samples in this document, you'll need:\n\n\n  Python 2.6 or greater\n  The pip package management tool.\n  The Google APIs Client Library for Python:\n    pip install --upgrade google-api-python-client\n  \n  The google-auth, google-auth-oauthlib, and\n    google-auth-httplib2 for user authorization.\n    pip install --upgrade google-auth google-auth-oauthlib google-auth-httplib2\n  \n  The Flask Python web application framework.\n    pip install --upgrade flask\n  \n  The requests HTTP library.\n    pip install --upgrade requests\n  \n\n\n      \n\n      \n\n        Ruby\n\n        To run the Ruby code samples in this document, you'll need:\n\n\n  Ruby 2.6 or greater\n  \n    The Google Auth Library for Ruby:\n    gem install googleauth\n  \n  \n    The Sinatra Ruby web application framework.\n    gem install sinatra\n  \n\n\n      \n\n      \n\n        Node.js\n\n        To run the Node.js code samples in this document, you'll need:\n\n\n  The maintenance LTS, active LTS, or current release of Node.js.\n  \n    The Google APIs Node.js Client:\n    npm install googleapis crypto express express-session\n  \n\n\n      \n\n      \n\n        HTTP/REST\n\n        You do not need to install any libraries to be able to directly call the OAuth 2.0\n          endpoints.\n\n      \n\n    ",
            "sectionWordCount": 229
          },
          {
            "sectionTitle": "PHP",
            "text": "To run the PHP code samples in this document, you'll need:\n  PHP 5.6 or greater with the command-line interface (CLI) and JSON extension installed.\n  The Composer dependency management tool.\n  \n    The Google APIs Client Library for PHP:\n    composer require google/apiclient:^2.10\n  \n",
            "sectionWordCount": 39
          },
          {
            "sectionTitle": "Python",
            "text": "To run the Python code samples in this document, you'll need:\n  Python 2.6 or greater\n  The pip package management tool.\n  The Google APIs Client Library for Python:\n    pip install --upgrade google-api-python-client\n  \n  The google-auth, google-auth-oauthlib, and\n    google-auth-httplib2 for user authorization.\n    pip install --upgrade google-auth google-auth-oauthlib google-auth-httplib2\n  \n  The Flask Python web application framework.\n    pip install --upgrade flask\n  \n  The requests HTTP library.\n    pip install --upgrade requests\n  \n",
            "sectionWordCount": 63
          },
          {
            "sectionTitle": "Ruby",
            "text": "To run the Ruby code samples in this document, you'll need:\n  Ruby 2.6 or greater\n  \n    The Google Auth Library for Ruby:\n    gem install googleauth\n  \n  \n    The Sinatra Ruby web application framework.\n    gem install sinatra\n  \n",
            "sectionWordCount": 33
          },
          {
            "sectionTitle": "Node.js",
            "text": "To run the Node.js code samples in this document, you'll need:\n  The maintenance LTS, active LTS, or current release of Node.js.\n  \n    The Google APIs Node.js Client:\n    npm install googleapis crypto express express-session\n  \n",
            "sectionWordCount": 32
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "You do not need to install any libraries to be able to directly call the OAuth 2.0\n          endpoints.",
            "sectionWordCount": 18
          },
          {
            "sectionTitle": "Obtaining OAuth 2.0 access tokens",
            "text": "The following steps show how your application interacts with Google's OAuth 2.0 server to obtain\n  a user's consent to perform an API request on the user's behalf. Your application must have that\n  consent before it can execute a Google API request that requires user authorization.The list below quickly summarizes these steps:\n      Your application identifies the permissions it needs.\n      Your application redirects the user to Google along with the list of requested\n        permissions.\n      The user decides whether to grant the permissions to your application.\n      Your application finds out what the user decided.\n      If the user granted the requested permissions, your application retrieves tokens needed to\n        make API requests on the user's behalf.\n    ",
            "sectionWordCount": 111
          },
          {
            "sectionTitle": "Step 1: Set authorization parameters",
            "text": "Your first step is to create the authorization request. That request sets parameters that\n      identify your application and define the permissions that the user will be asked to grant to\n      your application.\n      If you use a Google client library for OAuth 2.0 authentication and authorization, you\n        create and configure an object that defines these parameters.\n      If you call the Google OAuth 2.0 endpoint directly, you'll generate a URL and set the\n        parameters on that URL.\n    The tabs below define the supported authorization parameters for web server applications. The\n      language-specific examples also show how to use a client library or authorization library to\n      configure an object that sets those parameters.\n\n      \n\n        PHP\n\n        The code snippet below creates a Google\\Client() object, which defines the\n  parameters in the authorization request.\n\nThat object uses information from your client_secret.json file to identify your\n  application. (See creating authorization credentials for more about\n  that file.) The object also identifies the scopes that your application is requesting permission\n  to access and the URL to your application's auth endpoint, which will handle the response from\n  Google's OAuth 2.0 server. Finally, the code sets the optional access_type and\n  include_granted_scopes parameters.\n\n\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\n\n\n$client = new Google\\Client();\n\n// Required, call the setAuthConfig function to load authorization credentials from\n// client_secret.json file.\n$client->setAuthConfig('client_secret.json');\n\n// Required, to set the scope value, call the addScope function\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\n// Required, call the setRedirectUri function to specify a valid redirect URI for the\n// provided client_id\n$client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php');\n\n// Recommended, offline access will give you both an access and refresh token so that\n// your app can refresh the access token without user interaction.\n$client->setAccessType('offline');\n\n// Recommended, call the setState function. Using a state value can increase your assurance that\n// an incoming connection is the result of an authentication request.\n$client->setState($sample_passthrough_value);\n\n// Optional, if your application knows which user is trying to authenticate, it can use this\n// parameter to provide a hint to the Google Authentication Server.\n$client->setLoginHint('hint@example.com');\n\n// Optional, call the setPrompt function to set \"consent\" will prompt the user for consent\n$client->setPrompt('consent');\n\n// Optional, call the setIncludeGrantedScopes function with true to enable incremental\n// authorization\n$client->setIncludeGrantedScopes(true);\n\n      \n\n      \n\n        Python\n\n        The following code snippet uses the google-auth-oauthlib.flow module to construct\n  the authorization request.\n\nThe code constructs a Flow object, which identifies your application using\n  information from the client_secret.json file that you downloaded after\n  creating authorization credentials. That object also identifies the\n  scopes that your application is requesting permission to access and the URL to your application's\n  auth endpoint, which will handle the response from Google's OAuth 2.0 server. Finally, the code\n  sets the optional access_type and include_granted_scopes parameters.\n\n\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\n\n\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\n\n# Required, call the from_client_secrets_file method to retrieve the client ID from a\n# client_secret.json file. The client ID (from that file) and access scopes are required. (You can\n# also use the from_client_config method, which passes the client configuration as it originally\n# appeared in a client secrets file but doesn't access the file itself.)\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'])\n\n# Required, indicate where the API server will redirect the user after the user completes\n# the authorization flow. The redirect URI is required. The value must exactly\n# match one of the authorized redirect URIs for the OAuth 2.0 client, which you\n# configured in the API Console. If this value doesn't match an authorized URI,\n# you will get a 'redirect_uri_mismatch' error.\nflow.redirect_uri = 'https://www.example.com/oauth2callback'\n\n# Generate URL for request to Google's OAuth 2.0 server.\n# Use kwargs to set optional request parameters.\nauthorization_url, state = flow.authorization_url(\n    # Recommended, enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Optional, enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true',\n    # Optional, if your application knows which user is trying to authenticate, it can use this\n    # parameter to provide a hint to the Google Authentication Server.\n    login_hint='hint@example.com',\n    # Optional, set prompt to 'consent' will prompt the user for consent\n    prompt='consent')\n\n      \n\n      \n\n        Ruby\n\n        Use the client_secrets.json file that you created to configure a client object in your\n  application. When you configure a client object, you specify the scopes your application needs to\n  access, along with the URL to your application's auth endpoint, which will handle the response\n  from the OAuth 2.0 server.\n\n\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\n\n\nrequire 'google/apis/drive_v3'\nrequire \"googleauth\"\nrequire 'googleauth/stores/redis_token_store'\n\nclient_id = Google::Auth::ClientId.from_file('/path/to/client_secret.json')\nscope = 'https://www.googleapis.com/auth/drive.metadata.readonly'\ntoken_store = Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\nauthorizer = Google::Auth::WebUserAuthorizer.new(client_id, scope, token_store, '/oauth2callback')\n\nYour application uses the client object to perform OAuth 2.0 operations, such as generating\n  authorization request URLs and applying access tokens to HTTP requests.\n\n      \n\n      \n\n        Node.js\n\n        \n  The following code snippet creates a google.auth.OAuth2 object, which defines the\n  parameters in the authorization request.\n\n\n\n  That object uses information from your client_secret.json file to identify your application. To\n  ask for permissions from a user to retrieve an access token, you redirect them to a consent page.\n  To create a consent page URL:\n\n\nconst {google} = require('googleapis');\nconst crypto = require('crypto');\nconst express = require('express');\nconst session = require('express-session');\n\n/**\n * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI\n * from the client_secret.json file. To get these credentials for your application, visit\n * https://console.cloud.google.com/apis/credentials.\n */\nconst oauth2Client = new google.auth.OAuth2(\n  YOUR_CLIENT_ID,\n  YOUR_CLIENT_SECRET,\n  YOUR_REDIRECT_URL\n);\n\n// Access scopes for read-only Drive activity.\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly'\n];\n\n// Generate a secure random state value.\nconst state = crypto.randomBytes(32).toString('hex');\n\n// Store state in the session\nreq.session.state = state;\n\n// Generate a url that asks permissions for the Drive activity scope\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true,\n  // Include the state parameter to reduce the risk of CSRF attacks.\n  state: state\n});\n\n\n  Important Note - The refresh_token is only returned on the first\n  authorization. More details\n  \n    here.\n\n\n      \n\n      \n\n        HTTP/REST\n\n        Google's OAuth 2.0 endpoint is at https://accounts.google.com/o/oauth2/v2/auth. This\n          endpoint is accessible only over HTTPS. Plain HTTP connections are refused.\n\n      \n\n    The Google authorization server supports the following query string parameters for web\n      server applications:\n  \n    \n      Parameters\n    \n  \n  \n    \n      client_id\n      Required\n        The client ID for your application. You can find this value in the\n          API Console\n          Credentials page.\n        \n      \n    \n\n    \n    \n      redirect_uri\n      Required\n        \n        Determines where the API server redirects the user after the user completes the\n          authorization flow. The value must exactly match one of the authorized redirect URIs for\n          the OAuth 2.0 client, which you configured in your client's\n          API Console\n          Credentials page. If this value doesn't match an\n          authorized redirect URI for the provided client_id you will get a\n          redirect_uri_mismatch error.\n        Note that the http or https scheme, case, and trailing slash\n          ('/') must all match.\n          \n        \n      \n    \n\n    \n\n    \n      \n      \n        response_type\n        Required\n        \n        Determines whether the Google OAuth 2.0 endpoint returns an authorization code.\n          \n          Set the parameter value to code for web server applications.\n          \n        \n        \n      \n      \n    \n\n    \n      scope\n      Required\n        A\n          space-delimited\n          list of scopes that identify the resources that your application could access on the\n          user's behalf. These values inform the consent screen that Google displays to the\n          user.\n\n        Scopes enable your application to only request access to the resources that it needs\n          while also enabling users to control the amount of access that they grant to your\n          application. Thus, there is an inverse relationship between the number of scopes requested\n          and the likelihood of obtaining user consent.\n        \n        \n        \n        We recommend that your application request access to authorization scopes in context\n          whenever possible. By requesting access to user data in context, via\n          incremental authorization, you help users to more easily\n          understand why your application needs the access it is requesting.\n        \n      \n    \n\n    \n    \n      access_type\n      Recommended\n        Indicates whether your application can refresh access tokens when the user is not present\n          at the browser. Valid parameter values are online, which is the default\n          value, and offline.\n        Set the value to offline if your application needs to refresh access tokens\n          when the user is not present at the browser. This is the method of refreshing access\n          tokens described later in this document. This value instructs the Google authorization\n          server to return a refresh token and an access token the first time that your\n          application exchanges an authorization code for tokens.\n        \n      \n    \n    \n\n    \n\n    \n\n    \n    \n      state\n      Recommended\n        Specifies any string value that your application uses to maintain state between your\n          authorization request and the authorization server's response.\n          The server returns the exact value that you send as a name=value pair in the\n           URL query component (?) of the\n          redirect_uri after the user consents to or denies your application's\n          access request.\n        You can use this parameter for several purposes, such as directing the user to the\n          correct resource in your application, sending nonces, and mitigating cross-site request\n          forgery. Since your redirect_uri can be guessed, using a state\n          value can increase your assurance that an incoming connection is the result of an\n          authentication request. If you generate a random string or encode the hash of a cookie or\n          another value that captures the client's state, you can validate the response to\n          additionally ensure that the request and response originated in the same browser,\n          providing protection against attacks such as\n          cross-site request\n          forgery. See the\n          OpenID Connect\n          documentation for an example of how to create and confirm a state token.\n        \n        \n        \n          Important: The OAuth client must prevent CSRF as called out in the\n          OAuth2 Specification\n          . One way to achieve this is by using the state parameter to maintain\n          state between your authorization request and the authorization server's response.\n        \n      \n    \n    \n\n    \n    \n      include_granted_scopes\n      Optional\n        Enables applications to use incremental authorization to request access to additional\n          scopes in context. If you set this parameter's value to true and the\n          authorization request is granted, then the new access token will also cover any scopes to\n          which the user previously granted the application access. See the\n          incremental authorization section for examples.\n        \n      \n    \n    \n\n    \n    \n      enable_granular_consent\n      Optional\n        Defaults to true. If set to false,\n          more\n          granular Google Account permissions\n          will be disabled for OAuth client IDs created before 2019. No effect for newer\n          OAuth client IDs, since more granular permissions is always enabled for them.\n        When Google enables granular permissions for an application, this parameter will no\n          longer have any effect.\n      \n    \n    \n\n    \n    \n      login_hint\n      Optional\n        If your application knows which user is trying to authenticate, it can use this parameter\n          to provide a hint to the Google Authentication Server. The server uses the hint to\n          simplify the login flow either by prefilling the email field in the sign-in form or by\n          selecting the appropriate multi-login session.\n        Set the parameter value to an email address or sub identifier, which is\n          equivalent to the user's Google ID.\n        \n      \n    \n    \n\n    \n\n    \n    \n      prompt\n      Optional\n        A space-delimited, case-sensitive list of prompts to present the user. If you don't\n          specify this parameter, the user will be prompted only the first time your project\n          requests access. See \n          Prompting re-consent for more information.\n        \n\n        Possible values are:\n        \n          \n            none\n            Do not display any authentication or consent screens. Must not be specified with\n              other values.\n          \n          \n            consent\n            Prompt the user for consent.\n          \n          \n            select_account\n            Prompt the user to select an account.\n          \n        \n      \n    \n    \n  \n",
            "sectionWordCount": 1871
          },
          {
            "sectionTitle": "PHP",
            "text": "The code snippet below creates a Google\\Client() object, which defines the\n  parameters in the authorization request.That object uses information from your client_secret.json file to identify your\n  application. (See creating authorization credentials for more about\n  that file.) The object also identifies the scopes that your application is requesting permission\n  to access and the URL to your application's auth endpoint, which will handle the response from\n  Google's OAuth 2.0 server. Finally, the code sets the optional access_type and\n  include_granted_scopes parameters.\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\n$client = new Google\\Client();\n\n// Required, call the setAuthConfig function to load authorization credentials from\n// client_secret.json file.\n$client->setAuthConfig('client_secret.json');\n\n// Required, to set the scope value, call the addScope function\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\n// Required, call the setRedirectUri function to specify a valid redirect URI for the\n// provided client_id\n$client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php');\n\n// Recommended, offline access will give you both an access and refresh token so that\n// your app can refresh the access token without user interaction.\n$client->setAccessType('offline');\n\n// Recommended, call the setState function. Using a state value can increase your assurance that\n// an incoming connection is the result of an authentication request.\n$client->setState($sample_passthrough_value);\n\n// Optional, if your application knows which user is trying to authenticate, it can use this\n// parameter to provide a hint to the Google Authentication Server.\n$client->setLoginHint('hint@example.com');\n\n// Optional, call the setPrompt function to set \"consent\" will prompt the user for consent\n$client->setPrompt('consent');\n\n// Optional, call the setIncludeGrantedScopes function with true to enable incremental\n// authorization\n$client->setIncludeGrantedScopes(true);",
            "sectionWordCount": 256
          },
          {
            "sectionTitle": "Python",
            "text": "The following code snippet uses the google-auth-oauthlib.flow module to construct\n  the authorization request.The code constructs a Flow object, which identifies your application using\n  information from the client_secret.json file that you downloaded after\n  creating authorization credentials. That object also identifies the\n  scopes that your application is requesting permission to access and the URL to your application's\n  auth endpoint, which will handle the response from Google's OAuth 2.0 server. Finally, the code\n  sets the optional access_type and include_granted_scopes parameters.\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\n\n# Required, call the from_client_secrets_file method to retrieve the client ID from a\n# client_secret.json file. The client ID (from that file) and access scopes are required. (You can\n# also use the from_client_config method, which passes the client configuration as it originally\n# appeared in a client secrets file but doesn't access the file itself.)\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'])\n\n# Required, indicate where the API server will redirect the user after the user completes\n# the authorization flow. The redirect URI is required. The value must exactly\n# match one of the authorized redirect URIs for the OAuth 2.0 client, which you\n# configured in the API Console. If this value doesn't match an authorized URI,\n# you will get a 'redirect_uri_mismatch' error.\nflow.redirect_uri = 'https://www.example.com/oauth2callback'\n\n# Generate URL for request to Google's OAuth 2.0 server.\n# Use kwargs to set optional request parameters.\nauthorization_url, state = flow.authorization_url(\n    # Recommended, enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Optional, enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true',\n    # Optional, if your application knows which user is trying to authenticate, it can use this\n    # parameter to provide a hint to the Google Authentication Server.\n    login_hint='hint@example.com',\n    # Optional, set prompt to 'consent' will prompt the user for consent\n    prompt='consent')",
            "sectionWordCount": 322
          },
          {
            "sectionTitle": "Ruby",
            "text": "Use the client_secrets.json file that you created to configure a client object in your\n  application. When you configure a client object, you specify the scopes your application needs to\n  access, along with the URL to your application's auth endpoint, which will handle the response\n  from the OAuth 2.0 server.\nFor example, this code requests read-only, offline access to a user's\nGoogle Drive:\nrequire 'google/apis/drive_v3'\nrequire \"googleauth\"\nrequire 'googleauth/stores/redis_token_store'\n\nclient_id = Google::Auth::ClientId.from_file('/path/to/client_secret.json')\nscope = 'https://www.googleapis.com/auth/drive.metadata.readonly'\ntoken_store = Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\nauthorizer = Google::Auth::WebUserAuthorizer.new(client_id, scope, token_store, '/oauth2callback')Your application uses the client object to perform OAuth 2.0 operations, such as generating\n  authorization request URLs and applying access tokens to HTTP requests.",
            "sectionWordCount": 107
          },
          {
            "sectionTitle": "Node.js",
            "text": "\n  The following code snippet creates a google.auth.OAuth2 object, which defines the\n  parameters in the authorization request.\n\n  That object uses information from your client_secret.json file to identify your application. To\n  ask for permissions from a user to retrieve an access token, you redirect them to a consent page.\n  To create a consent page URL:\nconst {google} = require('googleapis');\nconst crypto = require('crypto');\nconst express = require('express');\nconst session = require('express-session');\n\n/**\n * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI\n * from the client_secret.json file. To get these credentials for your application, visit\n * https://console.cloud.google.com/apis/credentials.\n */\nconst oauth2Client = new google.auth.OAuth2(\n  YOUR_CLIENT_ID,\n  YOUR_CLIENT_SECRET,\n  YOUR_REDIRECT_URL\n);\n\n// Access scopes for read-only Drive activity.\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly'\n];\n\n// Generate a secure random state value.\nconst state = crypto.randomBytes(32).toString('hex');\n\n// Store state in the session\nreq.session.state = state;\n\n// Generate a url that asks permissions for the Drive activity scope\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true,\n  // Include the state parameter to reduce the risk of CSRF attacks.\n  state: state\n});\n  Important Note - The refresh_token is only returned on the first\n  authorization. More details\n  \n    here.\n",
            "sectionWordCount": 236
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "Google's OAuth 2.0 endpoint is at https://accounts.google.com/o/oauth2/v2/auth. This\n          endpoint is accessible only over HTTPS. Plain HTTP connections are refused.",
            "sectionWordCount": 19
          },
          {
            "sectionTitle": "Step 2: Redirect to Google's OAuth 2.0 server",
            "text": "Redirect the user to Google's OAuth 2.0 server to initiate the authentication and\n      authorization process. Typically, this occurs when your application first needs to access the\n      user's data. In the case of incremental authorization, this\n      step also occurs when your application first needs to access additional resources that it does\n      not yet have permission to access.\n\n      \n\n        PHP\n\n        \n  Generate a URL to request access from Google's OAuth 2.0 server:\n    $auth_url = $client->createAuthUrl();\n  \n  Redirect the user to $auth_url:\n    header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL));\n  \n\n\n      \n\n      \n\n        Python\n\n        This example shows how to redirect the user to the authorization URL using the Flask web\n  application framework:\n\nreturn flask.redirect(authorization_url)\n\n      \n\n      \n\n        Ruby\n\n        \n  Generate a URL to request access from Google's OAuth 2.0 server:\n    auth_uri = authorizer.get_authorization_url(login_hint: user_id, request: request)\n  Redirect the user to auth_uri.\n\n\n      \n\n      \n\n        Node.js\n\n        \n  \n    Use the generated URL authorizationUrl from Step 1\n    generateAuthUrl method to request access from Google's OAuth 2.0 server.\n  \n  \n    Redirect the user to authorizationUrl.\n    res.redirect(authorizationUrl);\n  \n\n\n      \n\n      \n\n        HTTP/REST\n\n        Sample redirect to Google's authorization server\n\n        \nAn example URL is shown below, with line breaks and spaces for readability.\n\n\n        https://accounts.google.com/o/oauth2/v2/auth?\n scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly&\n access_type=offline&\n include_granted_scopes=true&\n response_type=code&\n state=state_parameter_passthrough_value&\n redirect_uri=https%3A//oauth2.example.com/code&\n client_id=client_id\n\n        After you create the request URL, redirect the user to it.\n\n      \n\n    Google's OAuth 2.0 server authenticates the user and obtains consent from the user for your\n      application to access the requested scopes. The response is sent back to your application\n      using the redirect URL you specified.",
            "sectionWordCount": 224
          },
          {
            "sectionTitle": "PHP",
            "text": "\n  Generate a URL to request access from Google's OAuth 2.0 server:\n    $auth_url = $client->createAuthUrl();\n  \n  Redirect the user to $auth_url:\n    header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL));\n  \n",
            "sectionWordCount": 24
          },
          {
            "sectionTitle": "Python",
            "text": "This example shows how to redirect the user to the authorization URL using the Flask web\n  application framework:return flask.redirect(authorization_url)",
            "sectionWordCount": 19
          },
          {
            "sectionTitle": "Ruby",
            "text": "\n  Generate a URL to request access from Google's OAuth 2.0 server:\n    auth_uri = authorizer.get_authorization_url(login_hint: user_id, request: request)\n  Redirect the user to auth_uri.\n",
            "sectionWordCount": 22
          },
          {
            "sectionTitle": "Node.js",
            "text": "\n  \n    Use the generated URL authorizationUrl from Step 1\n    generateAuthUrl method to request access from Google's OAuth 2.0 server.\n  \n  \n    Redirect the user to authorizationUrl.\n    res.redirect(authorizationUrl);\n  \n",
            "sectionWordCount": 24
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "",
            "sectionWordCount": 0
          },
          {
            "sectionTitle": "Sample redirect to Google's authorization server",
            "text": "An example URL is shown below, with line breaks and spaces for readability.https://accounts.google.com/o/oauth2/v2/auth?\n scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly&\n access_type=offline&\n include_granted_scopes=true&\n response_type=code&\n state=state_parameter_passthrough_value&\n redirect_uri=https%3A//oauth2.example.com/code&\n client_id=client_idAfter you create the request URL, redirect the user to it.",
            "sectionWordCount": 30
          },
          {
            "sectionTitle": "Step 3: Google prompts user for consent",
            "text": "In this step, the user decides whether to grant your application the requested access. At this\n  stage, Google displays a consent window that shows the name of your application and the Google API\n  services that it is requesting permission to access with the user's authorization credentials and\n  a summary of the scopes of access to be granted. The\n  user can then consent to grant access to one or more scopes requested by your application or\n  refuse the request.Your application doesn't need to do anything at this stage as it waits for the response from\n  Google's OAuth 2.0 server indicating whether any access was granted. That response is explained in\n  the following step.\nErrors\n\nRequests to Google's OAuth 2.0 authorization endpoint may display user-facing error messages\n  instead of the expected authentication and authorization flows. Common error codes and suggested\n  resolutions are listed below.\n\n\nadmin_policy_enforced\n\nThe Google Account is unable to authorize one or more scopes requested due to the policies of\n  their Google Workspace administrator. See the Google Workspace Admin help article\n  \n    Control which third-party & internal apps access Google Workspace data\n  for more information about how an administrator may restrict access to all scopes or sensitive and\n  restricted scopes until access is explicitly granted to your OAuth client ID.\n\n\n\ndisallowed_useragent\n\nThe authorization endpoint is displayed inside an embedded user-agent disallowed by Google's\n  OAuth 2.0 Policies.\n\n\n  \n    Android\n    Android developers may encounter this error message when opening authorization requests in\n      android.webkit.WebView.\n      Developers should instead use Android libraries such as\n      Google Sign-In for Android or OpenID Foundation's\n      AppAuth for Android.\n    Web developers may encounter this error when an Android app opens a general web link in an\n      embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Android App Links\n      handlers or the default browser app. The\n      Android Custom Tabs\n      library is also a supported option.\n  \n\n  \n    iOS\n    iOS and macOS developers may encounter this error when opening authorization requests in\n      WKWebView.\n      Developers should instead use iOS libraries such as\n      Google Sign-In for iOS or OpenID Foundation's\n      AppAuth for iOS.\n    Web developers may encounter this error when an iOS or macOS app opens a general web link in\n      an embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Universal Links\n      handlers or the default browser app. The\n      SFSafariViewController\n      library is also a supported option.\n  \n\n\n\n\norg_internal\n\nThe OAuth client ID in the request is part of a project limiting access to Google Accounts in a\n  specific\n  \n    Google Cloud Organization.\n  For more information about this configuration option see the\n  User type\n  section in the Setting up your OAuth consent screen help article.\n\n\n\n\n\n\n  invalid_client\n\n  The OAuth client secret is incorrect. Review the\n    OAuth client\n    configuration, including the client ID and secret used for this request.\n\n\n\n\n  invalid_grant\n\n  \n    \n\n    \n    When refreshing an access token or using\n      incremental authorization, the token may have expired or has\n      been invalidated.\n    \n\n    \n\n    Authenticate the user again and ask for user consent to obtain new tokens. If you are continuing\n    to see this error, ensure that your application has been configured correctly and that you are\n    using the correct tokens and parameters in your request. Otherwise, the user account may have\n    been deleted or disabled.\n\n\n\n\n\nredirect_uri_mismatch\n\nThe redirect_uri passed in the authorization request does not match an authorized\n  redirect URI for the OAuth client ID. Review authorized redirect URIs in the\n  Google API Console Credentials page.\n\n\n\n\n\nThe redirect_uri parameter may refer to the OAuth out-of-band (OOB) flow that has\n  been deprecated and is no longer supported. Refer to the\n  migration guide to update your\n  integration.\n\n\n\n  invalid_request\n  There was something wrong with the request you made. This could be due to a number of reasons:\n  \n\n    \n      The request was not properly formatted\n      The request was missing required parameters\n       The request uses an authorization method that Google doesn't support. Verify your OAuth\n        integration uses a recommended integration method\n        \n    \n  \n\n",
            "sectionWordCount": 678
          },
          {
            "sectionTitle": "Errors",
            "text": "Requests to Google's OAuth 2.0 authorization endpoint may display user-facing error messages\n  instead of the expected authentication and authorization flows. Common error codes and suggested\n  resolutions are listed below.\nadmin_policy_enforced\n\nThe Google Account is unable to authorize one or more scopes requested due to the policies of\n  their Google Workspace administrator. See the Google Workspace Admin help article\n  \n    Control which third-party & internal apps access Google Workspace data\n  for more information about how an administrator may restrict access to all scopes or sensitive and\n  restricted scopes until access is explicitly granted to your OAuth client ID.\n\ndisallowed_useragent\n\nThe authorization endpoint is displayed inside an embedded user-agent disallowed by Google's\n  OAuth 2.0 Policies.\n\n\n  \n    Android\n    Android developers may encounter this error message when opening authorization requests in\n      android.webkit.WebView.\n      Developers should instead use Android libraries such as\n      Google Sign-In for Android or OpenID Foundation's\n      AppAuth for Android.\n    Web developers may encounter this error when an Android app opens a general web link in an\n      embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Android App Links\n      handlers or the default browser app. The\n      Android Custom Tabs\n      library is also a supported option.\n  \n\n  \n    iOS\n    iOS and macOS developers may encounter this error when opening authorization requests in\n      WKWebView.\n      Developers should instead use iOS libraries such as\n      Google Sign-In for iOS or OpenID Foundation's\n      AppAuth for iOS.\n    Web developers may encounter this error when an iOS or macOS app opens a general web link in\n      an embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Universal Links\n      handlers or the default browser app. The\n      SFSafariViewController\n      library is also a supported option.\n  \n\n\norg_internal\n\nThe OAuth client ID in the request is part of a project limiting access to Google Accounts in a\n  specific\n  \n    Google Cloud Organization.\n  For more information about this configuration option see the\n  User type\n  section in the Setting up your OAuth consent screen help article.\n\n  invalid_client\n\n  The OAuth client secret is incorrect. Review the\n    OAuth client\n    configuration, including the client ID and secret used for this request.\n\n  invalid_grant\n\n  \n    \n\n    \n    When refreshing an access token or using\n      incremental authorization, the token may have expired or has\n      been invalidated.\n    \n\n    \n\n    Authenticate the user again and ask for user consent to obtain new tokens. If you are continuing\n    to see this error, ensure that your application has been configured correctly and that you are\n    using the correct tokens and parameters in your request. Otherwise, the user account may have\n    been deleted or disabled.\n\nredirect_uri_mismatch\n\nThe redirect_uri passed in the authorization request does not match an authorized\n  redirect URI for the OAuth client ID. Review authorized redirect URIs in the\n  Google API Console Credentials page.\n\n\n\n\n\nThe redirect_uri parameter may refer to the OAuth out-of-band (OOB) flow that has\n  been deprecated and is no longer supported. Refer to the\n  migration guide to update your\n  integration.\n\n  invalid_request\n  There was something wrong with the request you made. This could be due to a number of reasons:\n  \n\n    \n      The request was not properly formatted\n      The request was missing required parameters\n       The request uses an authorization method that Google doesn't support. Verify your OAuth\n        integration uses a recommended integration method\n        \n    \n  ",
            "sectionWordCount": 565
          },
          {
            "sectionTitle": "admin_policy_enforced",
            "text": "The Google Account is unable to authorize one or more scopes requested due to the policies of\n  their Google Workspace administrator. See the Google Workspace Admin help article\n  \n    Control which third-party & internal apps access Google Workspace data\n  for more information about how an administrator may restrict access to all scopes or sensitive and\n  restricted scopes until access is explicitly granted to your OAuth client ID.",
            "sectionWordCount": 66
          },
          {
            "sectionTitle": "disallowed_useragent",
            "text": "The authorization endpoint is displayed inside an embedded user-agent disallowed by Google's\n  OAuth 2.0 Policies.\n  \n    Android\n    Android developers may encounter this error message when opening authorization requests in\n      android.webkit.WebView.\n      Developers should instead use Android libraries such as\n      Google Sign-In for Android or OpenID Foundation's\n      AppAuth for Android.\n    Web developers may encounter this error when an Android app opens a general web link in an\n      embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Android App Links\n      handlers or the default browser app. The\n      Android Custom Tabs\n      library is also a supported option.\n  \n\n  \n    iOS\n    iOS and macOS developers may encounter this error when opening authorization requests in\n      WKWebView.\n      Developers should instead use iOS libraries such as\n      Google Sign-In for iOS or OpenID Foundation's\n      AppAuth for iOS.\n    Web developers may encounter this error when an iOS or macOS app opens a general web link in\n      an embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Universal Links\n      handlers or the default browser app. The\n      SFSafariViewController\n      library is also a supported option.\n  \n",
            "sectionWordCount": 219
          },
          {
            "sectionTitle": "Android",
            "text": "Android developers may encounter this error message when opening authorization requests in\n      android.webkit.WebView.\n      Developers should instead use Android libraries such as\n      Google Sign-In for Android or OpenID Foundation's\n      AppAuth for Android.Web developers may encounter this error when an Android app opens a general web link in an\n      embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Android App Links\n      handlers or the default browser app. The\n      Android Custom Tabs\n      library is also a supported option.",
            "sectionWordCount": 100
          },
          {
            "sectionTitle": "iOS",
            "text": "iOS and macOS developers may encounter this error when opening authorization requests in\n      WKWebView.\n      Developers should instead use iOS libraries such as\n      Google Sign-In for iOS or OpenID Foundation's\n      AppAuth for iOS.Web developers may encounter this error when an iOS or macOS app opens a general web link in\n      an embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from\n      your site. Developers should allow general links to open in the default link handler of the\n      operating system, which includes both\n      Universal Links\n      handlers or the default browser app. The\n      SFSafariViewController\n      library is also a supported option.",
            "sectionWordCount": 100
          },
          {
            "sectionTitle": "org_internal",
            "text": "The OAuth client ID in the request is part of a project limiting access to Google Accounts in a\n  specific\n  \n    Google Cloud Organization.\n  For more information about this configuration option see the\n  User type\n  section in the Setting up your OAuth consent screen help article.",
            "sectionWordCount": 45
          },
          {
            "sectionTitle": "invalid_client",
            "text": "The OAuth client secret is incorrect. Review the\n    OAuth client\n    configuration, including the client ID and secret used for this request.",
            "sectionWordCount": 21
          },
          {
            "sectionTitle": "invalid_grant",
            "text": "\n    \n\n    \n    When refreshing an access token or using\n      incremental authorization, the token may have expired or has\n      been invalidated.\n    \n\n    \n\n    Authenticate the user again and ask for user consent to obtain new tokens. If you are continuing\n    to see this error, ensure that your application has been configured correctly and that you are\n    using the correct tokens and parameters in your request. Otherwise, the user account may have\n    been deleted or disabled.",
            "sectionWordCount": 70
          },
          {
            "sectionTitle": "redirect_uri_mismatch",
            "text": "The redirect_uri passed in the authorization request does not match an authorized\n  redirect URI for the OAuth client ID. Review authorized redirect URIs in the\n  Google API Console Credentials page.The redirect_uri parameter may refer to the OAuth out-of-band (OOB) flow that has\n  been deprecated and is no longer supported. Refer to the\n  migration guide to update your\n  integration.",
            "sectionWordCount": 58
          },
          {
            "sectionTitle": "invalid_request",
            "text": "There was something wrong with the request you made. This could be due to a number of reasons:\n  \n      The request was not properly formatted\n      The request was missing required parameters\n       The request uses an authorization method that Google doesn't support. Verify your OAuth\n        integration uses a recommended integration method\n        \n    ",
            "sectionWordCount": 49
          },
          {
            "sectionTitle": "Step 4: Handle the OAuth 2.0 server response",
            "text": "Important:\n      Before handling the OAuth 2.0 response on the server, you should confirm that the\n      state received from Google matches the state sent in the\n      authorization request. This verification helps to ensure that the user, not a malicious\n      script, is making the request and reduces the risk of\n      CSRF attacks.\n    The OAuth 2.0 server responds to your application's access request by using the URL specified\n      in the request.If the user approves the access request, then the response contains an authorization code. If\n      the user does not approve the request, the response contains an error message. The\n      authorization code or error message that is returned to the web server appears on the query\n      string, as shown below:An error response:https://oauth2.example.com/auth?error=access_deniedAn authorization code response:https://oauth2.example.com/auth?code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7Important: If your response endpoint renders an\n      HTML page, any resources on that page will be able to see the authorization code in the URL.\n      Scripts can read the URL directly, and the URL in the Referer HTTP header may be\n      sent to any or all resources on the page.\n\n      Carefully consider whether you want to send authorization credentials to all resources on\n        that page (especially third-party scripts such as social plugins and analytics). To avoid\n        this issue, we recommend that the server first handle the request, then redirect to another\n        URL that doesn't include the response parameters.",
            "sectionWordCount": 218
          },
          {
            "sectionTitle": "Sample OAuth 2.0 server response",
            "text": "\nYou can test this flow by clicking on the following sample URL, which requests\nread-only access to view metadata for files in your Google Drive:\nhttps://accounts.google.com/o/oauth2/v2/auth?\n scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly&\n access_type=offline&\n include_granted_scopes=true&\n response_type=code&\n state=state_parameter_passthrough_value&\n redirect_uri=https%3A//oauth2.example.com/code&\n client_id=client_idAfter completing the OAuth 2.0 flow, you should be redirected to\n      http://localhost/oauth2callback, which will likely yield a\n      404 NOT FOUND error unless your local machine serves a file at that address. The\n      next step provides more detail about the information returned in the URI when the user is\n      redirected back to your application.",
            "sectionWordCount": 85
          },
          {
            "sectionTitle": "Step 5: Exchange authorization code for refresh and access\n      tokens",
            "text": "After the web server receives the authorization code, it can exchange the authorization code\n      for an access token.\n\n      \n\n        PHP\n\n        To exchange an authorization code for an access token, use the authenticate\n  method:\n\n$client->authenticate($_GET['code']);\n\nYou can retrieve the access token with the getAccessToken method:\n\n$access_token = $client->getAccessToken();\n\n      \n\n      \n\n        Python\n\n        On your callback page, use the google-auth library to verify the authorization\n  server response. Then, use the flow.fetch_token method to exchange the authorization\n  code in that response for an access token:\n\nstate = flask.session['state']\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'],\n    state=state)\nflow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\nauthorization_response = flask.request.url\nflow.fetch_token(authorization_response=authorization_response)\n\n# Store the credentials in the session.\n# ACTION ITEM for developers:\n#     Store user's access and refresh tokens in your data store if\n#     incorporating this code into your real app.\ncredentials = flow.credentials\nflask.session['credentials'] = {\n    'token': credentials.token,\n    'refresh_token': credentials.refresh_token,\n    'token_uri': credentials.token_uri,\n    'client_id': credentials.client_id,\n    'client_secret': credentials.client_secret,\n    'scopes': credentials.scopes}\n\n      \n\n      \n\n        Ruby\n\n        On your callback page, use the googleauth library to verify the authorization server\n  response. Use the authorizer.handle_auth_callback_deferred method to save the\n  authorization code and redirect back to the URL that originally requested authorization. This\n  defers the exchange of the code by temporarily stashing the results in the user's session.\n\n  target_url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(request)\n  redirect target_url\n\n      \n\n      \n\n        Node.js\n\n        To exchange an authorization code for an access token, use the getToken\n  method:\n\nconst url = require('url');\n\n// Receive the callback from Google's OAuth 2.0 server.\napp.get('/oauth2callback', async (req, res) => {\n  let q = url.parse(req.url, true).query;\n\n  if (q.error) { // An error response e.g. error=access_denied\n    console.log('Error:' + q.error);\n  } else if (q.state !== req.session.state) { //check state value\n    console.log('State mismatch. Possible CSRF attack');\n    res.end('State mismatch. Possible CSRF attack');\n  } else { // Get access and refresh tokens (if access_type is offline)\n\n    let { tokens } = await oauth2Client.getToken(q.code);\n    oauth2Client.setCredentials(tokens);\n});\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo exchange an authorization code for an access token, call the\n  https://oauth2.googleapis.com/token endpoint and set the following parameters:\n\n\n  \n    \n      Fields\n    \n  \n  \n    \n      client_id\n      The client ID obtained from the API Console\n        Credentials page.\n    \n\n    \n      client_secret\n      The client secret obtained from the API Console\n        Credentials page.\n    \n\n    \n      code\n      The authorization code returned from the initial request.\n    \n\n    \n\n    \n      grant_type\n      As defined in the OAuth 2.0\n        specification, this field's value must be set to authorization_code.\n    \n    \n      redirect_uri\n      One of the redirect URIs listed for your project in the\n        API Console\n        Credentials page for the given\n        client_id.\n    \n  \n\n\nThe following snippet shows a sample request:\n\nPOST /token HTTP/1.1\nHost: oauth2.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\ncode=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7&\nclient_id=your_client_id&\nclient_secret=your_client_secret&\nredirect_uri=https%3A//oauth2.example.com/code&\ngrant_type=authorization_code\n\nGoogle responds to this request by returning a JSON object that contains a short-lived access\n  token and a refresh token.\n\n  Note that the refresh token is only returned if your application set the access_type\n  parameter to offline in the initial request to Google's\n  authorization server.\n\n\n\nThe response contains the following fields:\n\n\n  \n    \n      Fields\n    \n  \n  \n    \n      access_token\n      The token that your application sends to authorize a Google API request.\n    \n    \n      expires_in\n      The remaining lifetime of the access token in seconds.\n    \n\n    \n    \n      refresh_token\n      A token that you can use to obtain a new access token. Refresh tokens are valid until the\n        user revokes access.\n    \n        Again, this field is only present in this response if you set the access_type\n        parameter to offline in the initial request to Google's authorization server.\n    \n      \n    \n    \n      scope\n      The scopes of access granted by the access_token expressed as a list of\n        space-delimited, case-sensitive strings.\n    \n    \n      token_type\n      The type of token returned. At this time, this field's value is always set to\n        Bearer.\n    \n  \n\n\nImportant: Your application should store both tokens in a secure,\n  long-lived location that is accessible between different invocations of your application. The\n  refresh token enables your application to obtain a new access token if the one that you have\n  expires. As such, if your application loses the refresh token, the user will need to repeat the\n  OAuth 2.0 consent flow so that your application can obtain a new refresh token.\n\n\n\nThe following snippet shows a sample response:\n\n{\n  \"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\n  \"expires_in\": 3920,\n  \"token_type\": \"Bearer\",\n  \"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\n  \"refresh_token\": \"1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI\"\n}\n\nNote: Your application should ignore any unrecognized fields included in\n  the response.\n\n      \n\n    \n    Errors\n\n    When exchanging the authorization code for an access token you may encounter the following\n      error instead of the expected response. Common error codes and suggested resolutions are\n      listed below.\n\n      \n        invalid_grant\n\n        The supplied authorization code is invalid or in the wrong format. Request a new code by\n          restarting the OAuth process to prompt the user for consent\n          again.\n      \n    ",
            "sectionWordCount": 713
          },
          {
            "sectionTitle": "PHP",
            "text": "To exchange an authorization code for an access token, use the authenticate\n  method:$client->authenticate($_GET['code']);You can retrieve the access token with the getAccessToken method:$access_token = $client->getAccessToken();",
            "sectionWordCount": 24
          },
          {
            "sectionTitle": "Python",
            "text": "On your callback page, use the google-auth library to verify the authorization\n  server response. Then, use the flow.fetch_token method to exchange the authorization\n  code in that response for an access token:state = flask.session['state']\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'],\n    state=state)\nflow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\nauthorization_response = flask.request.url\nflow.fetch_token(authorization_response=authorization_response)\n\n# Store the credentials in the session.\n# ACTION ITEM for developers:\n#     Store user's access and refresh tokens in your data store if\n#     incorporating this code into your real app.\ncredentials = flow.credentials\nflask.session['credentials'] = {\n    'token': credentials.token,\n    'refresh_token': credentials.refresh_token,\n    'token_uri': credentials.token_uri,\n    'client_id': credentials.client_id,\n    'client_secret': credentials.client_secret,\n    'scopes': credentials.scopes}",
            "sectionWordCount": 97
          },
          {
            "sectionTitle": "Ruby",
            "text": "On your callback page, use the googleauth library to verify the authorization server\n  response. Use the authorizer.handle_auth_callback_deferred method to save the\n  authorization code and redirect back to the URL that originally requested authorization. This\n  defers the exchange of the code by temporarily stashing the results in the user's session.  target_url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(request)\n  redirect target_url",
            "sectionWordCount": 54
          },
          {
            "sectionTitle": "Node.js",
            "text": "To exchange an authorization code for an access token, use the getToken\n  method:const url = require('url');\n\n// Receive the callback from Google's OAuth 2.0 server.\napp.get('/oauth2callback', async (req, res) => {\n  let q = url.parse(req.url, true).query;\n\n  if (q.error) { // An error response e.g. error=access_denied\n    console.log('Error:' + q.error);\n  } else if (q.state !== req.session.state) { //check state value\n    console.log('State mismatch. Possible CSRF attack');\n    res.end('State mismatch. Possible CSRF attack');\n  } else { // Get access and refresh tokens (if access_type is offline)\n\n    let { tokens } = await oauth2Client.getToken(q.code);\n    oauth2Client.setCredentials(tokens);\n});",
            "sectionWordCount": 90
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "To exchange an authorization code for an access token, call the\n  https://oauth2.googleapis.com/token endpoint and set the following parameters:\n  \n    \n      Fields\n    \n  \n  \n    \n      client_id\n      The client ID obtained from the API Console\n        Credentials page.\n    \n\n    \n      client_secret\n      The client secret obtained from the API Console\n        Credentials page.\n    \n\n    \n      code\n      The authorization code returned from the initial request.\n    \n\n    \n\n    \n      grant_type\n      As defined in the OAuth 2.0\n        specification, this field's value must be set to authorization_code.\n    \n    \n      redirect_uri\n      One of the redirect URIs listed for your project in the\n        API Console\n        Credentials page for the given\n        client_id.\n    \n  \nThe following snippet shows a sample request:POST /token HTTP/1.1\nHost: oauth2.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\ncode=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7&\nclient_id=your_client_id&\nclient_secret=your_client_secret&\nredirect_uri=https%3A//oauth2.example.com/code&\ngrant_type=authorization_codeGoogle responds to this request by returning a JSON object that contains a short-lived access\n  token and a refresh token.\n\n  Note that the refresh token is only returned if your application set the access_type\n  parameter to offline in the initial request to Google's\n  authorization server.\n\nThe response contains the following fields:\n  \n    \n      Fields\n    \n  \n  \n    \n      access_token\n      The token that your application sends to authorize a Google API request.\n    \n    \n      expires_in\n      The remaining lifetime of the access token in seconds.\n    \n\n    \n    \n      refresh_token\n      A token that you can use to obtain a new access token. Refresh tokens are valid until the\n        user revokes access.\n    \n        Again, this field is only present in this response if you set the access_type\n        parameter to offline in the initial request to Google's authorization server.\n    \n      \n    \n    \n      scope\n      The scopes of access granted by the access_token expressed as a list of\n        space-delimited, case-sensitive strings.\n    \n    \n      token_type\n      The type of token returned. At this time, this field's value is always set to\n        Bearer.\n    \n  \nImportant: Your application should store both tokens in a secure,\n  long-lived location that is accessible between different invocations of your application. The\n  refresh token enables your application to obtain a new access token if the one that you have\n  expires. As such, if your application loses the refresh token, the user will need to repeat the\n  OAuth 2.0 consent flow so that your application can obtain a new refresh token.The following snippet shows a sample response:{\n  \"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\n  \"expires_in\": 3920,\n  \"token_type\": \"Bearer\",\n  \"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\n  \"refresh_token\": \"1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI\"\n}Note: Your application should ignore any unrecognized fields included in\n  the response.",
            "sectionWordCount": 357
          },
          {
            "sectionTitle": "Errors",
            "text": "When exchanging the authorization code for an access token you may encounter the following\n      error instead of the expected response. Common error codes and suggested resolutions are\n      listed below.\n        invalid_grant\n\n        The supplied authorization code is invalid or in the wrong format. Request a new code by\n          restarting the OAuth process to prompt the user for consent\n          again.\n      ",
            "sectionWordCount": 57
          },
          {
            "sectionTitle": "invalid_grant",
            "text": "The supplied authorization code is invalid or in the wrong format. Request a new code by\n          restarting the OAuth process to prompt the user for consent\n          again.",
            "sectionWordCount": 27
          },
          {
            "sectionTitle": "Calling Google APIs",
            "text": "\n\n      \n\n        PHP\n\n        Use the access token to call Google APIs by completing the following steps:\n\n\n  If you need to apply an access token to a new Google\\Client object — for\n    example, if you stored the access token in a user session — use the\n    setAccessToken method:\n\n    $client->setAccessToken($access_token);\n  \n  Build a service object for the API that you want to call. You build a service object by\n    providing an authorized Google\\Client object to the constructor for the API you\n    want to call. \nFor example, to call the Drive API:\n\n    $drive = new Google\\Service\\Drive($client);\n  \n  Make requests to the API service using the\n    interface provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    $files = $drive->files->listFiles(array())->getItems();\n  \n\n\n      \n\n      \n\n        Python\n\n        After obtaining an access token, your application can use that token to authorize API requests on\n  behalf of a given user account or service account. Use the user-specific authorization credentials\n  to build a service object for the API that you want to call, and then use that object to make\n  authorized API requests.\n\n\n  Build a service object for the API that you want to call. You build a service object by\n    calling the googleapiclient.discovery library's build method with the\n    name and version of the API and the user credentials:\n    \nFor example, to call version 3 of the Drive API:\n\n    from googleapiclient.discovery import build\n\ndrive = build('drive', 'v2', credentials=credentials)\n  \n  Make requests to the API service using the\n    interface provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    files = drive.files().list().execute()\n  \n\n\n      \n\n      \n\n        Ruby\n\n        After obtaining an access token, your application can use that token to make API requests on\n  behalf of a given user account or service account. Use the user-specific authorization credentials\n  to build a service object for the API that you want to call, and then use that object to make\n  authorized API requests.\n\n\n  Build a service object for the API that you want to call.\n    \nFor example, to call version 3 of the Drive API:\n\n    drive = Google::Apis::DriveV3::DriveService.new\n  \n  Set the credentials on the service:\n    drive.authorization = credentials\n  \n  Make requests to the API service using the\n    interface\n      provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    \n    files = drive.list_files\n    \n  \n\n\nAlternately, authorization can be provided on a per-method basis by supplying the\n  options parameter to a method:\n\n\nfiles = drive.list_files(options: { authorization: credentials })\n\n\n      \n\n      \n\n        Node.js\n\n        After obtaining an access token and setting it to the OAuth2 object, use the object\n  to call Google APIs. Your application can use that token to authorize API requests on behalf of\n  a given user account or service account. Build a service object for the API that you want to call.\n\nconst { google } = require('googleapis');\n\n// Example of using Google Drive API to list filenames in user's Drive.\nconst drive = google.drive('v3');\ndrive.files.list({\n  auth: oauth2Client,\n  pageSize: 10,\n  fields: 'nextPageToken, files(id, name)',\n}, (err1, res1) => {\n  if (err1) return console.log('The API returned an error: ' + err1);\n  const files = res1.data.files;\n  if (files.length) {\n    console.log('Files:');\n    files.map((file) => {\n      console.log(`${file.name} (${file.id})`);\n    });\n  } else {\n    console.log('No files found.');\n  }\n});\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter your application obtains an access token, you can use the token to make calls to a Google\n  API on behalf of a given\n  user account if the scope(s) of access required by the API have been granted. To do this, include\n  the access token in a request to the API by including either an access_token query\n  parameter or an Authorization HTTP header Bearer value. When possible,\n  the HTTP header is preferable, because query strings tend to be visible in server logs. In most\n  cases you can use a client library to set up your calls to Google APIs (for example, when\n  calling the Drive Files API).\n\n\n\nYou can try out all the Google APIs and view their scopes at the\n  OAuth 2.0 Playground.\n\nHTTP GET examples\n\nA call to the\n  \n    drive.files\n  endpoint (the Drive Files API) using the Authorization: Bearer HTTP\n  header might look like the following. Note that you need to specify your own access token:\n\nGET /drive/v2/files HTTP/1.1\nHost: www.googleapis.com\nAuthorization: Bearer access_token\n\nHere is a call to the same API for the authenticated user using the access_token\n  query string parameter:\n\nGET https://www.googleapis.com/drive/v2/files?access_token=access_token\n\ncurl examples\n\nYou can test these commands with the curl command-line application. Here's an\n  example that uses the HTTP header option (preferred):\n\ncurl -H \"Authorization: Bearer access_token\" https://www.googleapis.com/drive/v2/files\n\nOr, alternatively, the query string parameter option:\n\ncurl https://www.googleapis.com/drive/v2/files?access_token=access_token\n\n      \n\n    ",
            "sectionWordCount": 744
          },
          {
            "sectionTitle": "PHP",
            "text": "Use the access token to call Google APIs by completing the following steps:\n  If you need to apply an access token to a new Google\\Client object — for\n    example, if you stored the access token in a user session — use the\n    setAccessToken method:\n\n    $client->setAccessToken($access_token);\n  \n  Build a service object for the API that you want to call. You build a service object by\n    providing an authorized Google\\Client object to the constructor for the API you\n    want to call. \nFor example, to call the Drive API:\n\n    $drive = new Google\\Service\\Drive($client);\n  \n  Make requests to the API service using the\n    interface provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    $files = $drive->files->listFiles(array())->getItems();\n  \n",
            "sectionWordCount": 118
          },
          {
            "sectionTitle": "Python",
            "text": "After obtaining an access token, your application can use that token to authorize API requests on\n  behalf of a given user account or service account. Use the user-specific authorization credentials\n  to build a service object for the API that you want to call, and then use that object to make\n  authorized API requests.\n  Build a service object for the API that you want to call. You build a service object by\n    calling the googleapiclient.discovery library's build method with the\n    name and version of the API and the user credentials:\n    \nFor example, to call version 3 of the Drive API:\n\n    from googleapiclient.discovery import build\n\ndrive = build('drive', 'v2', credentials=credentials)\n  \n  Make requests to the API service using the\n    interface provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    files = drive.files().list().execute()\n  \n",
            "sectionWordCount": 137
          },
          {
            "sectionTitle": "Ruby",
            "text": "After obtaining an access token, your application can use that token to make API requests on\n  behalf of a given user account or service account. Use the user-specific authorization credentials\n  to build a service object for the API that you want to call, and then use that object to make\n  authorized API requests.\n  Build a service object for the API that you want to call.\n    \nFor example, to call version 3 of the Drive API:\n\n    drive = Google::Apis::DriveV3::DriveService.new\n  \n  Set the credentials on the service:\n    drive.authorization = credentials\n  \n  Make requests to the API service using the\n    interface\n      provided by the service object.\n    \nFor example, to list the files in the authenticated user's Google Drive:\n\n    \n    files = drive.list_files\n    \n  \nAlternately, authorization can be provided on a per-method basis by supplying the\n  options parameter to a method:files = drive.list_files(options: { authorization: credentials })",
            "sectionWordCount": 139
          },
          {
            "sectionTitle": "Node.js",
            "text": "After obtaining an access token and setting it to the OAuth2 object, use the object\n  to call Google APIs. Your application can use that token to authorize API requests on behalf of\n  a given user account or service account. Build a service object for the API that you want to call.const { google } = require('googleapis');\n\n// Example of using Google Drive API to list filenames in user's Drive.\nconst drive = google.drive('v3');\ndrive.files.list({\n  auth: oauth2Client,\n  pageSize: 10,\n  fields: 'nextPageToken, files(id, name)',\n}, (err1, res1) => {\n  if (err1) return console.log('The API returned an error: ' + err1);\n  const files = res1.data.files;\n  if (files.length) {\n    console.log('Files:');\n    files.map((file) => {\n      console.log(`${file.name} (${file.id})`);\n    });\n  } else {\n    console.log('No files found.');\n  }\n});",
            "sectionWordCount": 120
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "After your application obtains an access token, you can use the token to make calls to a Google\n  API on behalf of a given\n  user account if the scope(s) of access required by the API have been granted. To do this, include\n  the access token in a request to the API by including either an access_token query\n  parameter or an Authorization HTTP header Bearer value. When possible,\n  the HTTP header is preferable, because query strings tend to be visible in server logs. In most\n  cases you can use a client library to set up your calls to Google APIs (for example, when\n  calling the Drive Files API).You can try out all the Google APIs and view their scopes at the\n  OAuth 2.0 Playground.",
            "sectionWordCount": 123
          },
          {
            "sectionTitle": "HTTP GET examples",
            "text": "A call to the\n  \n    drive.files\n  endpoint (the Drive Files API) using the Authorization: Bearer HTTP\n  header might look like the following. Note that you need to specify your own access token:\n\nGET /drive/v2/files HTTP/1.1\nHost: www.googleapis.com\nAuthorization: Bearer access_tokenHere is a call to the same API for the authenticated user using the access_token\n  query string parameter:GET https://www.googleapis.com/drive/v2/files?access_token=access_token",
            "sectionWordCount": 57
          },
          {
            "sectionTitle": "curl examples",
            "text": "You can test these commands with the curl command-line application. Here's an\n  example that uses the HTTP header option (preferred):curl -H \"Authorization: Bearer access_token\" https://www.googleapis.com/drive/v2/filesOr, alternatively, the query string parameter option:curl https://www.googleapis.com/drive/v2/files?access_token=access_token",
            "sectionWordCount": 32
          },
          {
            "sectionTitle": "Complete example",
            "text": "The following example prints a JSON-formatted list of files in a user's Google Drive after the\n  user authenticates and gives consent for the application to access the user's Drive metadata.\n\n      \n\n        PHP\n\n        To run this example:\n\n\n  In the API Console, add the URL of the local machine to the\n    list of redirect URLs. For example, add http://localhost:8080.\n  Create a new directory and change to it. For example:\n    mkdir ~/php-oauth2-example\ncd ~/php-oauth2-example\n  Install the Google API Client\n    Library for PHP using Composer:\n      composer require google/apiclient:^2.10\n  Create the files index.php and oauth2callback.php with the content\n    below.\n  Run the example with a web server configured to serve PHP. If you use PHP 5.6 or newer, you\n    can use PHP's built-in test web server:\n      php -S localhost:8080 ~/php-oauth2-example\n\n\nindex.php\n\n<?php\nrequire_once __DIR__.'/vendor/autoload.php';\n\nsession_start();\n\n$client = new Google\\Client();\n$client->setAuthConfig('client_secrets.json');\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\nif (isset($_SESSION['access_token']) && $_SESSION['access_token']) {\n  $client->setAccessToken($_SESSION['access_token']);\n  $drive = new Google\\Service\\Drive($client);\n  $files = $drive->files->listFiles(array())->getItems();\n  echo json_encode($files);\n} else {\n  $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php';\n  header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL));\n}\n\noauth2callback.php\n\n<?php\nrequire_once __DIR__.'/vendor/autoload.php';\n\nsession_start();\n\n$client = new Google\\Client();\n$client->setAuthConfigFile('client_secrets.json');\n$client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php');\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\nif (! isset($_GET['code'])) {\n  // Generate and set state value\n  $state = bin2hex(random_bytes(16));\n  $client->setState($state);\n  $_SESSION['state'] = $state;\n\n  $auth_url = $client->createAuthUrl();\n  header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL));\n} else {\n  // Check the state value\n  if (!isset($_GET['state']) || $_GET['state'] !== $_SESSION['state']) {\n    die('State mismatch. Possible CSRF attack.');\n  }\n  $client->authenticate($_GET['code']);\n  $_SESSION['access_token'] = $client->getAccessToken();\n  $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/';\n  header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL));\n}\n\n      \n\n      \n\n        Python\n\n        This example uses the Flask framework. It\n  runs a web application at http://localhost:8080 that lets you test the OAuth 2.0\n  flow. If you go to that URL, you should see four links:\n\n\n  Test an API request: This link points to a page that tries to execute a sample API\n    request. If necessary, it starts the authorization flow. If successful, the page displays the\n    API response.\n  Test the auth flow directly: This link points to a page that tries to send the user\n    through the authorization flow. The app requests permission to\n    submit authorized API requests on the user's behalf.\n  Revoke current credentials: This link points to a page that \n    revokes permissions that the user has already granted to the application.\n  Clear Flask session credentials: This link clears authorization credentials that are\n    stored in the Flask session. This lets you see what would happen if a user who had already\n    granted permission to your app tried to execute an API request in a new session. It also lets\n    you see the API response your app would get if a user had revoked permissions granted to your\n    app, and your app still tried to authorize a request with a revoked access token.\n\n\nNote: To run this code locally, you must have followed the directions in\n  the prerequisites section, including setting\n  http://localhost:8080 as a valid redirect URI for your credentials and downloading\n  the client_secret.json file for those credentials to your working directory.\n\n# -*- coding: utf-8 -*-\n\nimport os\nimport flask\nimport requests\n\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\nimport googleapiclient.discovery\n\n# This variable specifies the name of a file that contains the OAuth 2.0\n# information for this application, including its client_id and client_secret.\nCLIENT_SECRETS_FILE = \"client_secret.json\"\n\n# This OAuth 2.0 access scope allows for full read/write access to the\n# authenticated user's account and requires requests to use an SSL connection.\nSCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly']\nAPI_SERVICE_NAME = 'drive'\nAPI_VERSION = 'v2'\n\napp = flask.Flask(__name__)\n# Note: A secret key is included in the sample so that it works.\n# If you use this code in your application, replace this with a truly secret\n# key. See https://flask.palletsprojects.com/quickstart/#sessions.\napp.secret_key = 'REPLACE ME - this value is here as a placeholder.'\n\n\n@app.route('/')\ndef index():\n  return print_index_table()\n\n\n@app.route('/test')\ndef test_api_request():\n  if 'credentials' not in flask.session:\n    return flask.redirect('authorize')\n\n  # Load credentials from the session.\n  credentials = google.oauth2.credentials.Credentials(\n      **flask.session['credentials'])\n\n  drive = googleapiclient.discovery.build(\n      API_SERVICE_NAME, API_VERSION, credentials=credentials)\n\n  files = drive.files().list().execute()\n\n  # Save credentials back to session in case access token was refreshed.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  flask.session['credentials'] = credentials_to_dict(credentials)\n\n  return flask.jsonify(**files)\n\n\n@app.route('/authorize')\ndef authorize():\n  # Create flow instance to manage the OAuth 2.0 Authorization Grant Flow steps.\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES)\n\n  # The URI created here must exactly match one of the authorized redirect URIs\n  # for the OAuth 2.0 client, which you configured in the API Console. If this\n  # value doesn't match an authorized URI, you will get a 'redirect_uri_mismatch'\n  # error.\n  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\n  authorization_url, state = flow.authorization_url(\n      # Enable offline access so that you can refresh an access token without\n      # re-prompting the user for permission. Recommended for web server apps.\n      access_type='offline',\n      # Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes='true')\n\n  # Store the state so the callback can verify the auth server response.\n  flask.session['state'] = state\n\n  return flask.redirect(authorization_url)\n\n\n@app.route('/oauth2callback')\ndef oauth2callback():\n  # Specify the state when creating the flow in the callback so that it can\n  # verified in the authorization server response.\n  state = flask.session['state']\n\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)\n  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\n  # Use the authorization server's response to fetch the OAuth 2.0 tokens.\n  authorization_response = flask.request.url\n  flow.fetch_token(authorization_response=authorization_response)\n\n  # Store credentials in the session.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  credentials = flow.credentials\n  flask.session['credentials'] = credentials_to_dict(credentials)\n\n  return flask.redirect(flask.url_for('test_api_request'))\n\n\n@app.route('/revoke')\ndef revoke():\n  if 'credentials' not in flask.session:\n    return ('You need to <a href=\"/authorize\">authorize</a> before ' +\n            'testing the code to revoke credentials.')\n\n  credentials = google.oauth2.credentials.Credentials(\n    **flask.session['credentials'])\n\n  revoke = requests.post('https://oauth2.googleapis.com/revoke',\n      params={'token': credentials.token},\n      headers = {'content-type': 'application/x-www-form-urlencoded'})\n\n  status_code = getattr(revoke, 'status_code')\n  if status_code == 200:\n    return('Credentials successfully revoked.' + print_index_table())\n  else:\n    return('An error occurred.' + print_index_table())\n\n\n@app.route('/clear')\ndef clear_credentials():\n  if 'credentials' in flask.session:\n    del flask.session['credentials']\n  return ('Credentials have been cleared.<br><br>' +\n          print_index_table())\n\n\ndef credentials_to_dict(credentials):\n  return {'token': credentials.token,\n          'refresh_token': credentials.refresh_token,\n          'token_uri': credentials.token_uri,\n          'client_id': credentials.client_id,\n          'client_secret': credentials.client_secret,\n          'scopes': credentials.scopes}\n\ndef print_index_table():\n  return ('<table>' +\n          '<tr><td><a href=\"/test\">Test an API request</a></td>' +\n          '<td>Submit an API request and see a formatted JSON response. ' +\n          '    Go through the authorization flow if there are no stored ' +\n          '    credentials for the user.</td></tr>' +\n          '<tr><td><a href=\"/authorize\">Test the auth flow directly</a></td>' +\n          '<td>Go directly to the authorization flow. If there are stored ' +\n          '    credentials, you still might not be prompted to reauthorize ' +\n          '    the application.</td></tr>' +\n          '<tr><td><a href=\"/revoke\">Revoke current credentials</a></td>' +\n          '<td>Revoke the access token associated with the current user ' +\n          '    session. After revoking credentials, if you go to the test ' +\n          '    page, you should see an <code>invalid_grant</code> error.' +\n          '</td></tr>' +\n          '<tr><td><a href=\"/clear\">Clear Flask session credentials</a></td>' +\n          '<td>Clear the access token currently stored in the user session. ' +\n          '    After clearing the token, if you <a href=\"/test\">test the ' +\n          '    API request</a> again, you should go back to the auth flow.' +\n          '</td></tr></table>')\n\n\nif __name__ == '__main__':\n  # When running locally, disable OAuthlib's HTTPs verification.\n  # ACTION ITEM for developers:\n  #     When running in production *do not* leave this option enabled.\n  os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n  # Specify a hostname and port that are set as a valid redirect URI\n  # for your API project in the Google API Console.\n  app.run('localhost', 8080, debug=True)\n\n      \n\n      \n\n        Ruby\n\n        This example uses the Sinatra framework.\n\nrequire 'google/apis/drive_v3'\nrequire 'sinatra'\nrequire 'googleauth'\nrequire 'googleauth/stores/redis_token_store'\n\nconfigure do\n  enable :sessions\n\n  set :client_id, Google::Auth::ClientId.from_file('/path/to/client_secret.json')\n  set :scope, Google::Apis::DriveV3::AUTH_DRIVE_METADATA_READONLY\n  set :token_store, Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\n  set :authorizer, Google::Auth::WebUserAuthorizer.new(settings.client_id, settings.scope, settings.token_store, '/oauth2callback')\nend\n\nget '/' do\n  user_id = settings.client_id.id\n  credentials = settings.authorizer.get_credentials(user_id, request)\n  if credentials.nil?\n    redirect settings.authorizer.get_authorization_url(login_hint: user_id, request: request)\n  end\n  drive = Google::Apis::DriveV3::DriveService.new\n  files = drive.list_files(options: { authorization: credentials })\n  \"<pre>#{JSON.pretty_generate(files.to_h)}</pre>\"\nend\n\nget '/oauth2callback' do\n  target_url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(request)\n  redirect target_url\nend\n\n      \n\n      \n\n        Node.js\n\n        To run this example:\n\n\n  \n    In the API Console, add the URL of the\n    local machine to the list of redirect URLs. For example, add\n    http://localhost.\n  \n  \n    Make sure you have maintenance LTS, active LTS, or current release of\n    Node.js installed.\n  \n  \n    Create a new directory and change to it. For example:\n    mkdir ~/nodejs-oauth2-example\ncd ~/nodejs-oauth2-example\n  \n  \n    Install the\n    Google API Client\n      Library\n    for Node.js using npm:\n    npm install googleapis\n  \n  \n    Create the files main.js with the content below.\n  \n  \n    Run the example:\n    node .\\main.js\n  \n\nmain.js\nconst http = require('http');\nconst https = require('https');\nconst url = require('url');\nconst { google } = require('googleapis');\nconst crypto = require('crypto');\nconst express = require('express');\nconst session = require('express-session');\n\n/**\n * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI.\n * To get these credentials for your application, visit\n * https://console.cloud.google.com/apis/credentials.\n */\nconst oauth2Client = new google.auth.OAuth2(\n  YOUR_CLIENT_ID,\n  YOUR_CLIENT_SECRET,\n  YOUR_REDIRECT_URL\n);\n\n// Access scopes for read-only Drive activity.\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly'\n];\n/* Global variable that stores user credential in this code example.\n * ACTION ITEM for developers:\n *   Store user's refresh token in your data store if\n *   incorporating this code into your real app.\n *   For more information on handling refresh tokens,\n *   see https://github.com/googleapis/google-api-nodejs-client#handling-refresh-tokens\n */\nlet userCredential = null;\n\nasync function main() {\n  const app = express();\n\n  app.use(session({\n    secret: 'your_secure_secret_key', // Replace with a strong secret\n    resave: false,\n    saveUninitialized: false,\n  }));\n\n  // Example on redirecting user to Google's OAuth 2.0 server.\n  app.get('/', async (req, res) => {\n    // Generate a secure random state value.\n    const state = crypto.randomBytes(32).toString('hex');\n    // Store state in the session\n    req.session.state = state;\n\n    // Generate a url that asks permissions for the Drive activity scope\n    const authorizationUrl = oauth2Client.generateAuthUrl({\n      // 'online' (default) or 'offline' (gets refresh_token)\n      access_type: 'offline',\n      /** Pass in the scopes array defined above.\n        * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n      scope: scopes,\n      // Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes: true,\n      // Include the state parameter to reduce the risk of CSRF attacks.\n      state: state\n    });\n\n    res.redirect(authorizationUrl);\n  });\n\n  // Receive the callback from Google's OAuth 2.0 server.\n  app.get('/oauth2callback', async (req, res) => {\n    // Handle the OAuth 2.0 server response\n    let q = url.parse(req.url, true).query;\n\n    if (q.error) { // An error response e.g. error=access_denied\n      console.log('Error:' + q.error);\n    } else if (q.state !== req.session.state) { //check state value\n      console.log('State mismatch. Possible CSRF attack');\n      res.end('State mismatch. Possible CSRF attack');\n    } else { // Get access and refresh tokens (if access_type is offline)\n      let { tokens } = await oauth2Client.getToken(q.code);\n      oauth2Client.setCredentials(tokens);\n\n      /** Save credential to the global variable in case access token was refreshed.\n        * ACTION ITEM: In a production app, you likely want to save the refresh token\n        *              in a secure persistent database instead. */\n      userCredential = tokens;\n\n      // Example of using Google Drive API to list filenames in user's Drive.\n      const drive = google.drive('v3');\n      drive.files.list({\n        auth: oauth2Client,\n        pageSize: 10,\n        fields: 'nextPageToken, files(id, name)',\n      }, (err1, res1) => {\n        if (err1) return console.log('The API returned an error: ' + err1);\n        const files = res1.data.files;\n        if (files.length) {\n          console.log('Files:');\n          files.map((file) => {\n            console.log(`${file.name} (${file.id})`);\n          });\n        } else {\n          console.log('No files found.');\n        }\n      });\n    }\n  });\n\n  // Example on revoking a token\n  app.get('/revoke', async (req, res) => {\n    // Build the string for the POST request\n    let postData = \"token=\" + userCredential.access_token;\n\n    // Options for POST request to Google's OAuth 2.0 server to revoke a token\n    let postOptions = {\n      host: 'oauth2.googleapis.com',\n      port: '443',\n      path: '/revoke',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData)\n      }\n    };\n\n    // Set up the request\n    const postReq = https.request(postOptions, function (res) {\n      res.setEncoding('utf8');\n      res.on('data', d => {\n        console.log('Response: ' + d);\n      });\n    });\n\n    postReq.on('error', error => {\n      console.log(error)\n    });\n\n    // Post the request with data\n    postReq.write(postData);\n    postReq.end();\n  });\n\n\n  const server = http.createServer(app);\n  server.listen(80);\n}\nmain().catch(console.error);\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\nThis Python example uses the Flask framework\n  and the Requests library to demonstrate the OAuth\n  2.0 web flow. We recommend using the Google API Client Library for Python for this flow. (The\n  example in the Python tab does use the client library.)\n\nimport json\n\nimport flask\nimport requests\n\n\napp = flask.Flask(__name__)\n\nCLIENT_ID = '123456789.apps.googleusercontent.com'\nCLIENT_SECRET = 'abc123'  # Read from a file or environmental variable in a real app\nSCOPE = 'https://www.googleapis.com/auth/drive.metadata.readonly'\nREDIRECT_URI = 'http://example.com/oauth2callback'\n\n\n@app.route('/')\ndef index():\n  if 'credentials' not in flask.session:\n    return flask.redirect(flask.url_for('oauth2callback'))\n  credentials = json.loads(flask.session['credentials'])\n  if credentials['expires_in'] <= 0:\n    return flask.redirect(flask.url_for('oauth2callback'))\n  else:\n    headers = {'Authorization': 'Bearer {}'.format(credentials['access_token'])}\n    req_uri = 'https://www.googleapis.com/drive/v2/files'\n    r = requests.get(req_uri, headers=headers)\n    return r.text\n\n\n@app.route('/oauth2callback')\ndef oauth2callback():\n  if 'code' not in flask.request.args:\n    state = str(uuid.uuid4())\n    flask.session['state'] = state\n    auth_uri = ('https://accounts.google.com/o/oauth2/v2/auth?response_type=code'\n                '&client_id={}&redirect_uri={}&scope={}&state={}').format(CLIENT_ID, REDIRECT_URI,\n                                                                          SCOPE, state)\n    return flask.redirect(auth_uri)\n  else:\n    if 'state' not in flask.request.args or flask.request.args['state'] != flask.session['state']:\n      return 'State mismatch. Possible CSRF attack.', 400\n\n    auth_code = flask.request.args.get('code')\n    data = {'code': auth_code,\n            'client_id': CLIENT_ID,\n            'client_secret': CLIENT_SECRET,\n            'redirect_uri': REDIRECT_URI,\n            'grant_type': 'authorization_code'}\n    r = requests.post('https://oauth2.googleapis.com/token', data=data)\n    flask.session['credentials'] = r.text\n    return flask.redirect(flask.url_for('index'))\n\n\nif __name__ == '__main__':\n  import uuid\n  app.secret_key = str(uuid.uuid4())\n  app.debug = False\n  app.run()\n\n      \n\n    ",
            "sectionWordCount": 2100
          },
          {
            "sectionTitle": "PHP",
            "text": "To run this example:\n  In the API Console, add the URL of the local machine to the\n    list of redirect URLs. For example, add http://localhost:8080.\n  Create a new directory and change to it. For example:\n    mkdir ~/php-oauth2-example\ncd ~/php-oauth2-example\n  Install the Google API Client\n    Library for PHP using Composer:\n      composer require google/apiclient:^2.10\n  Create the files index.php and oauth2callback.php with the content\n    below.\n  Run the example with a web server configured to serve PHP. If you use PHP 5.6 or newer, you\n    can use PHP's built-in test web server:\n      php -S localhost:8080 ~/php-oauth2-example\n",
            "sectionWordCount": 92
          },
          {
            "sectionTitle": "index.php",
            "text": "<?php\nrequire_once __DIR__.'/vendor/autoload.php';\n\nsession_start();\n\n$client = new Google\\Client();\n$client->setAuthConfig('client_secrets.json');\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\nif (isset($_SESSION['access_token']) && $_SESSION['access_token']) {\n  $client->setAccessToken($_SESSION['access_token']);\n  $drive = new Google\\Service\\Drive($client);\n  $files = $drive->files->listFiles(array())->getItems();\n  echo json_encode($files);\n} else {\n  $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php';\n  header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL));\n}",
            "sectionWordCount": 41
          },
          {
            "sectionTitle": "oauth2callback.php",
            "text": "<?php\nrequire_once __DIR__.'/vendor/autoload.php';\n\nsession_start();\n\n$client = new Google\\Client();\n$client->setAuthConfigFile('client_secrets.json');\n$client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php');\n$client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY);\n\nif (! isset($_GET['code'])) {\n  // Generate and set state value\n  $state = bin2hex(random_bytes(16));\n  $client->setState($state);\n  $_SESSION['state'] = $state;\n\n  $auth_url = $client->createAuthUrl();\n  header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL));\n} else {\n  // Check the state value\n  if (!isset($_GET['state']) || $_GET['state'] !== $_SESSION['state']) {\n    die('State mismatch. Possible CSRF attack.');\n  }\n  $client->authenticate($_GET['code']);\n  $_SESSION['access_token'] = $client->getAccessToken();\n  $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/';\n  header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL));\n}",
            "sectionWordCount": 78
          },
          {
            "sectionTitle": "Python",
            "text": "This example uses the Flask framework. It\n  runs a web application at http://localhost:8080 that lets you test the OAuth 2.0\n  flow. If you go to that URL, you should see four links:\n  Test an API request: This link points to a page that tries to execute a sample API\n    request. If necessary, it starts the authorization flow. If successful, the page displays the\n    API response.\n  Test the auth flow directly: This link points to a page that tries to send the user\n    through the authorization flow. The app requests permission to\n    submit authorized API requests on the user's behalf.\n  Revoke current credentials: This link points to a page that \n    revokes permissions that the user has already granted to the application.\n  Clear Flask session credentials: This link clears authorization credentials that are\n    stored in the Flask session. This lets you see what would happen if a user who had already\n    granted permission to your app tried to execute an API request in a new session. It also lets\n    you see the API response your app would get if a user had revoked permissions granted to your\n    app, and your app still tried to authorize a request with a revoked access token.\nNote: To run this code locally, you must have followed the directions in\n  the prerequisites section, including setting\n  http://localhost:8080 as a valid redirect URI for your credentials and downloading\n  the client_secret.json file for those credentials to your working directory.# -*- coding: utf-8 -*-\n\nimport os\nimport flask\nimport requests\n\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\nimport googleapiclient.discovery\n\n# This variable specifies the name of a file that contains the OAuth 2.0\n# information for this application, including its client_id and client_secret.\nCLIENT_SECRETS_FILE = \"client_secret.json\"\n\n# This OAuth 2.0 access scope allows for full read/write access to the\n# authenticated user's account and requires requests to use an SSL connection.\nSCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly']\nAPI_SERVICE_NAME = 'drive'\nAPI_VERSION = 'v2'\n\napp = flask.Flask(__name__)\n# Note: A secret key is included in the sample so that it works.\n# If you use this code in your application, replace this with a truly secret\n# key. See https://flask.palletsprojects.com/quickstart/#sessions.\napp.secret_key = 'REPLACE ME - this value is here as a placeholder.'\n\n\n@app.route('/')\ndef index():\n  return print_index_table()\n\n\n@app.route('/test')\ndef test_api_request():\n  if 'credentials' not in flask.session:\n    return flask.redirect('authorize')\n\n  # Load credentials from the session.\n  credentials = google.oauth2.credentials.Credentials(\n      **flask.session['credentials'])\n\n  drive = googleapiclient.discovery.build(\n      API_SERVICE_NAME, API_VERSION, credentials=credentials)\n\n  files = drive.files().list().execute()\n\n  # Save credentials back to session in case access token was refreshed.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  flask.session['credentials'] = credentials_to_dict(credentials)\n\n  return flask.jsonify(**files)\n\n\n@app.route('/authorize')\ndef authorize():\n  # Create flow instance to manage the OAuth 2.0 Authorization Grant Flow steps.\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES)\n\n  # The URI created here must exactly match one of the authorized redirect URIs\n  # for the OAuth 2.0 client, which you configured in the API Console. If this\n  # value doesn't match an authorized URI, you will get a 'redirect_uri_mismatch'\n  # error.\n  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\n  authorization_url, state = flow.authorization_url(\n      # Enable offline access so that you can refresh an access token without\n      # re-prompting the user for permission. Recommended for web server apps.\n      access_type='offline',\n      # Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes='true')\n\n  # Store the state so the callback can verify the auth server response.\n  flask.session['state'] = state\n\n  return flask.redirect(authorization_url)\n\n\n@app.route('/oauth2callback')\ndef oauth2callback():\n  # Specify the state when creating the flow in the callback so that it can\n  # verified in the authorization server response.\n  state = flask.session['state']\n\n  flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n      CLIENT_SECRETS_FILE, scopes=SCOPES, state=state)\n  flow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\n  # Use the authorization server's response to fetch the OAuth 2.0 tokens.\n  authorization_response = flask.request.url\n  flow.fetch_token(authorization_response=authorization_response)\n\n  # Store credentials in the session.\n  # ACTION ITEM: In a production app, you likely want to save these\n  #              credentials in a persistent database instead.\n  credentials = flow.credentials\n  flask.session['credentials'] = credentials_to_dict(credentials)\n\n  return flask.redirect(flask.url_for('test_api_request'))\n\n\n@app.route('/revoke')\ndef revoke():\n  if 'credentials' not in flask.session:\n    return ('You need to <a href=\"/authorize\">authorize</a> before ' +\n            'testing the code to revoke credentials.')\n\n  credentials = google.oauth2.credentials.Credentials(\n    **flask.session['credentials'])\n\n  revoke = requests.post('https://oauth2.googleapis.com/revoke',\n      params={'token': credentials.token},\n      headers = {'content-type': 'application/x-www-form-urlencoded'})\n\n  status_code = getattr(revoke, 'status_code')\n  if status_code == 200:\n    return('Credentials successfully revoked.' + print_index_table())\n  else:\n    return('An error occurred.' + print_index_table())\n\n\n@app.route('/clear')\ndef clear_credentials():\n  if 'credentials' in flask.session:\n    del flask.session['credentials']\n  return ('Credentials have been cleared.<br><br>' +\n          print_index_table())\n\n\ndef credentials_to_dict(credentials):\n  return {'token': credentials.token,\n          'refresh_token': credentials.refresh_token,\n          'token_uri': credentials.token_uri,\n          'client_id': credentials.client_id,\n          'client_secret': credentials.client_secret,\n          'scopes': credentials.scopes}\n\ndef print_index_table():\n  return ('<table>' +\n          '<tr><td><a href=\"/test\">Test an API request</a></td>' +\n          '<td>Submit an API request and see a formatted JSON response. ' +\n          '    Go through the authorization flow if there are no stored ' +\n          '    credentials for the user.</td></tr>' +\n          '<tr><td><a href=\"/authorize\">Test the auth flow directly</a></td>' +\n          '<td>Go directly to the authorization flow. If there are stored ' +\n          '    credentials, you still might not be prompted to reauthorize ' +\n          '    the application.</td></tr>' +\n          '<tr><td><a href=\"/revoke\">Revoke current credentials</a></td>' +\n          '<td>Revoke the access token associated with the current user ' +\n          '    session. After revoking credentials, if you go to the test ' +\n          '    page, you should see an <code>invalid_grant</code> error.' +\n          '</td></tr>' +\n          '<tr><td><a href=\"/clear\">Clear Flask session credentials</a></td>' +\n          '<td>Clear the access token currently stored in the user session. ' +\n          '    After clearing the token, if you <a href=\"/test\">test the ' +\n          '    API request</a> again, you should go back to the auth flow.' +\n          '</td></tr></table>')\n\n\nif __name__ == '__main__':\n  # When running locally, disable OAuthlib's HTTPs verification.\n  # ACTION ITEM for developers:\n  #     When running in production *do not* leave this option enabled.\n  os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n  # Specify a hostname and port that are set as a valid redirect URI\n  # for your API project in the Google API Console.\n  app.run('localhost', 8080, debug=True)",
            "sectionWordCount": 953
          },
          {
            "sectionTitle": "Ruby",
            "text": "This example uses the Sinatra framework.require 'google/apis/drive_v3'\nrequire 'sinatra'\nrequire 'googleauth'\nrequire 'googleauth/stores/redis_token_store'\n\nconfigure do\n  enable :sessions\n\n  set :client_id, Google::Auth::ClientId.from_file('/path/to/client_secret.json')\n  set :scope, Google::Apis::DriveV3::AUTH_DRIVE_METADATA_READONLY\n  set :token_store, Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\n  set :authorizer, Google::Auth::WebUserAuthorizer.new(settings.client_id, settings.scope, settings.token_store, '/oauth2callback')\nend\n\nget '/' do\n  user_id = settings.client_id.id\n  credentials = settings.authorizer.get_credentials(user_id, request)\n  if credentials.nil?\n    redirect settings.authorizer.get_authorization_url(login_hint: user_id, request: request)\n  end\n  drive = Google::Apis::DriveV3::DriveService.new\n  files = drive.list_files(options: { authorization: credentials })\n  \"<pre>#{JSON.pretty_generate(files.to_h)}</pre>\"\nend\n\nget '/oauth2callback' do\n  target_url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(request)\n  redirect target_url\nend",
            "sectionWordCount": 73
          },
          {
            "sectionTitle": "Node.js",
            "text": "To run this example:\n  \n    In the API Console, add the URL of the\n    local machine to the list of redirect URLs. For example, add\n    http://localhost.\n  \n  \n    Make sure you have maintenance LTS, active LTS, or current release of\n    Node.js installed.\n  \n  \n    Create a new directory and change to it. For example:\n    mkdir ~/nodejs-oauth2-example\ncd ~/nodejs-oauth2-example\n  \n  \n    Install the\n    Google API Client\n      Library\n    for Node.js using npm:\n    npm install googleapis\n  \n  \n    Create the files main.js with the content below.\n  \n  \n    Run the example:\n    node .\\main.js\n  \n",
            "sectionWordCount": 79
          },
          {
            "sectionTitle": "main.js",
            "text": "const http = require('http');\nconst https = require('https');\nconst url = require('url');\nconst { google } = require('googleapis');\nconst crypto = require('crypto');\nconst express = require('express');\nconst session = require('express-session');\n\n/**\n * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI.\n * To get these credentials for your application, visit\n * https://console.cloud.google.com/apis/credentials.\n */\nconst oauth2Client = new google.auth.OAuth2(\n  YOUR_CLIENT_ID,\n  YOUR_CLIENT_SECRET,\n  YOUR_REDIRECT_URL\n);\n\n// Access scopes for read-only Drive activity.\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly'\n];\n/* Global variable that stores user credential in this code example.\n * ACTION ITEM for developers:\n *   Store user's refresh token in your data store if\n *   incorporating this code into your real app.\n *   For more information on handling refresh tokens,\n *   see https://github.com/googleapis/google-api-nodejs-client#handling-refresh-tokens\n */\nlet userCredential = null;\n\nasync function main() {\n  const app = express();\n\n  app.use(session({\n    secret: 'your_secure_secret_key', // Replace with a strong secret\n    resave: false,\n    saveUninitialized: false,\n  }));\n\n  // Example on redirecting user to Google's OAuth 2.0 server.\n  app.get('/', async (req, res) => {\n    // Generate a secure random state value.\n    const state = crypto.randomBytes(32).toString('hex');\n    // Store state in the session\n    req.session.state = state;\n\n    // Generate a url that asks permissions for the Drive activity scope\n    const authorizationUrl = oauth2Client.generateAuthUrl({\n      // 'online' (default) or 'offline' (gets refresh_token)\n      access_type: 'offline',\n      /** Pass in the scopes array defined above.\n        * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n      scope: scopes,\n      // Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes: true,\n      // Include the state parameter to reduce the risk of CSRF attacks.\n      state: state\n    });\n\n    res.redirect(authorizationUrl);\n  });\n\n  // Receive the callback from Google's OAuth 2.0 server.\n  app.get('/oauth2callback', async (req, res) => {\n    // Handle the OAuth 2.0 server response\n    let q = url.parse(req.url, true).query;\n\n    if (q.error) { // An error response e.g. error=access_denied\n      console.log('Error:' + q.error);\n    } else if (q.state !== req.session.state) { //check state value\n      console.log('State mismatch. Possible CSRF attack');\n      res.end('State mismatch. Possible CSRF attack');\n    } else { // Get access and refresh tokens (if access_type is offline)\n      let { tokens } = await oauth2Client.getToken(q.code);\n      oauth2Client.setCredentials(tokens);\n\n      /** Save credential to the global variable in case access token was refreshed.\n        * ACTION ITEM: In a production app, you likely want to save the refresh token\n        *              in a secure persistent database instead. */\n      userCredential = tokens;\n\n      // Example of using Google Drive API to list filenames in user's Drive.\n      const drive = google.drive('v3');\n      drive.files.list({\n        auth: oauth2Client,\n        pageSize: 10,\n        fields: 'nextPageToken, files(id, name)',\n      }, (err1, res1) => {\n        if (err1) return console.log('The API returned an error: ' + err1);\n        const files = res1.data.files;\n        if (files.length) {\n          console.log('Files:');\n          files.map((file) => {\n            console.log(`${file.name} (${file.id})`);\n          });\n        } else {\n          console.log('No files found.');\n        }\n      });\n    }\n  });\n\n  // Example on revoking a token\n  app.get('/revoke', async (req, res) => {\n    // Build the string for the POST request\n    let postData = \"token=\" + userCredential.access_token;\n\n    // Options for POST request to Google's OAuth 2.0 server to revoke a token\n    let postOptions = {\n      host: 'oauth2.googleapis.com',\n      port: '443',\n      path: '/revoke',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData)\n      }\n    };\n\n    // Set up the request\n    const postReq = https.request(postOptions, function (res) {\n      res.setEncoding('utf8');\n      res.on('data', d => {\n        console.log('Response: ' + d);\n      });\n    });\n\n    postReq.on('error', error => {\n      console.log(error)\n    });\n\n    // Post the request with data\n    postReq.write(postData);\n    postReq.end();\n  });\n\n\n  const server = http.createServer(app);\n  server.listen(80);\n}\nmain().catch(console.error);",
            "sectionWordCount": 558
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "This Python example uses the Flask framework\n  and the Requests library to demonstrate the OAuth\n  2.0 web flow. We recommend using the Google API Client Library for Python for this flow. (The\n  example in the Python tab does use the client library.)import json\n\nimport flask\nimport requests\n\n\napp = flask.Flask(__name__)\n\nCLIENT_ID = '123456789.apps.googleusercontent.com'\nCLIENT_SECRET = 'abc123'  # Read from a file or environmental variable in a real app\nSCOPE = 'https://www.googleapis.com/auth/drive.metadata.readonly'\nREDIRECT_URI = 'http://example.com/oauth2callback'\n\n\n@app.route('/')\ndef index():\n  if 'credentials' not in flask.session:\n    return flask.redirect(flask.url_for('oauth2callback'))\n  credentials = json.loads(flask.session['credentials'])\n  if credentials['expires_in'] <= 0:\n    return flask.redirect(flask.url_for('oauth2callback'))\n  else:\n    headers = {'Authorization': 'Bearer {}'.format(credentials['access_token'])}\n    req_uri = 'https://www.googleapis.com/drive/v2/files'\n    r = requests.get(req_uri, headers=headers)\n    return r.text\n\n\n@app.route('/oauth2callback')\ndef oauth2callback():\n  if 'code' not in flask.request.args:\n    state = str(uuid.uuid4())\n    flask.session['state'] = state\n    auth_uri = ('https://accounts.google.com/o/oauth2/v2/auth?response_type=code'\n                '&client_id={}&redirect_uri={}&scope={}&state={}').format(CLIENT_ID, REDIRECT_URI,\n                                                                          SCOPE, state)\n    return flask.redirect(auth_uri)\n  else:\n    if 'state' not in flask.request.args or flask.request.args['state'] != flask.session['state']:\n      return 'State mismatch. Possible CSRF attack.', 400\n\n    auth_code = flask.request.args.get('code')\n    data = {'code': auth_code,\n            'client_id': CLIENT_ID,\n            'client_secret': CLIENT_SECRET,\n            'redirect_uri': REDIRECT_URI,\n            'grant_type': 'authorization_code'}\n    r = requests.post('https://oauth2.googleapis.com/token', data=data)\n    flask.session['credentials'] = r.text\n    return flask.redirect(flask.url_for('index'))\n\n\nif __name__ == '__main__':\n  import uuid\n  app.secret_key = str(uuid.uuid4())\n  app.debug = False\n  app.run()",
            "sectionWordCount": 185
          },
          {
            "sectionTitle": "Redirect URI validation rules",
            "text": "Google applies the following validation rules to redirect URIs in order to help developers\n      keep their applications secure. Your redirect URIs must adhere to these rules. See\n      RFC 3986 section 3 for the\n      definition of domain, host, path, query, scheme and userinfo, mentioned below.\n    \n  \n    \n      Validation rules\n    \n  \n  \n    \n      Scheme\n      \n        \n          Redirect URIs must use the HTTPS scheme, not plain HTTP. Localhost URIs (including\n          localhost IP address URIs) are exempt from this rule.\n        \n      \n    \n\n    \n      Host\n      \n        Hosts cannot be raw IP addresses. Localhost IP addresses are exempted from this rule.\n      \n    \n\n    \n      Domain\n      \n        Host TLDs\n          (Top Level Domains)\n          must belong to the public suffix list.\n        Host domains cannot be “googleusercontent.com”.\n        \n          Redirect URIs cannot contain URL shortener domains (e.g. goo.gl) unless\n            the app owns the domain. Furthermore, if an app that owns a shortener domain chooses to\n            redirect to that domain, that redirect URI must either contain\n            “/google-callback/” in its path or end with\n            “/google-callback”.\n        \n      \n    \n\n    \n      Userinfo\n      \n        \n          Redirect URIs cannot contain the userinfo subcomponent.\n        \n      \n    \n\n    \n      Path\n      \n        \n          Redirect URIs cannot contain a path traversal (also called directory backtracking),\n            which is represented by an “/..” or “\\..” or their URL\n            encoding.\n        \n      \n    \n\n    \n      Query\n      \n        \n          Redirect URIs cannot contain\n            open redirects.\n        \n      \n    \n\n    \n      Fragment\n      \n        \n          Redirect URIs cannot contain the fragment component.\n        \n      \n    \n\n    \n      Characters\n      \n        \n          Redirect URIs cannot contain certain characters including:\n        \n\n        \n          Wildcard characters ('*')\n          Non-printable ASCII characters\n          Invalid percent encodings (any percent encoding that does not follow URL-encoding\n            form of a percent sign followed by two hexadecimal digits)\n          Null characters (an encoded NULL character, e.g., %00,\n            %C0%80)\n        \n      \n    \n  \n",
            "sectionWordCount": 237
          },
          {
            "sectionTitle": "Incremental authorization",
            "text": "In the OAuth 2.0 protocol, your app requests authorization to access resources, which are\n  identified by scopes. It is considered a best user-experience practice to request authorization\n  for resources at the time you need them. To enable that practice, Google's authorization server\n  supports incremental authorization. This feature lets you request scopes as they are needed and,\n  if the user grants permission for the new scope, returns an authorization code that may be\n  exchanged for a token containing all scopes the user has granted the project.For example, an app that lets people sample music tracks and create mixes might need very few\n  resources at sign-in time, perhaps nothing more than the name of the person signing in. However,\n  saving a completed mix would require access to their Google Drive. Most people would find it\n  natural if they only were asked for access to their Google Drive at the time the app actually\n  needed it.In this case, at sign-in time the app might request the openid and\n  profile scopes to perform basic sign-in, and then later request the\n  https://www.googleapis.com/auth/drive.file scope at the time of the first request to save a\n  mix.To implement incremental authorization, you complete the normal flow for requesting an access\n  token but make sure that the authorization request includes previously granted scopes. This\n  approach allows your app to avoid having to manage multiple access tokens.The following rules apply to an access token obtained from an incremental authorization:\n  The token can be used to access resources corresponding to any of the scopes rolled into the\n    new, combined authorization.\n  When you use the refresh token for the combined authorization to obtain an access token, the\n    access token represents the combined authorization and can be used for any of the\n    scope values included in the response.\n  The combined authorization includes all scopes that the user granted to the API project even\n    if the grants were requested from different clients. For example, if a user granted access to\n    one scope using an application's desktop client and then granted another scope to the same\n    application via a mobile client, the combined authorization would include both scopes.\n  If you revoke a token that represents a combined authorization, access to all of that\n    authorization's scopes on behalf of the associated user are revoked simultaneously.\nCaution: choosing to include granted scopes will automatically add\n  scopes previously granted by the user to your authorization request. A warning or error page may\n  be displayed if your app is not currently approved to request all scopes that may be returned in\n  the response. See\n  Unverified apps for\n  more information.The language-specific code samples in Step 1: Set authorization\n      parameters and the sample HTTP/REST redirect URL in Step 2:\n      Redirect to Google's OAuth 2.0 server all use incremental authorization. The code samples\n      below also show the code that you need to add to use incremental authorization.\n\n      \n\n        PHP\n\n        $client->setIncludeGrantedScopes(true);\n\n      \n\n      \n\n        Python\n\n        In Python, set the include_granted_scopes keyword argument to true to\n  ensure that an authorization request includes previously granted scopes. It is very possible that\n  include_granted_scopes will not be the only keyword argument that you set, as\n  shown in the example below.\n\nauthorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')\n\n      \n\n      \n\n        Ruby\n\n        auth_client.update!(\n  :additional_parameters => {\"include_granted_scopes\" => \"true\"}\n)\n\n      \n\n      \n\n        Node.js\n\n        const authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});\n\n      \n\n      \n\n        HTTP/REST\n\n        \n        \nGET https://accounts.google.com/o/oauth2/v2/auth?\n  client_id=your_client_id&\n  response_type=code&\n  state=state_parameter_passthrough_value&\n  scope=https%3A//www.googleapis.com/auth/drive.file&\n  redirect_uri=https%3A//oauth2.example.com/code&\n  prompt=consent&\n  include_granted_scopes=true\n\n\n      \n\n    ",
            "sectionWordCount": 629
          },
          {
            "sectionTitle": "PHP",
            "text": "$client->setIncludeGrantedScopes(true);",
            "sectionWordCount": 1
          },
          {
            "sectionTitle": "Python",
            "text": "In Python, set the include_granted_scopes keyword argument to true to\n  ensure that an authorization request includes previously granted scopes. It is very possible that\n  include_granted_scopes will not be the only keyword argument that you set, as\n  shown in the example below.authorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')",
            "sectionWordCount": 79
          },
          {
            "sectionTitle": "Ruby",
            "text": "auth_client.update!(\n  :additional_parameters => {\"include_granted_scopes\" => \"true\"}\n)",
            "sectionWordCount": 7
          },
          {
            "sectionTitle": "Node.js",
            "text": "const authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});",
            "sectionWordCount": 53
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "GET https://accounts.google.com/o/oauth2/v2/auth?\n  client_id=your_client_id&\n  response_type=code&\n  state=state_parameter_passthrough_value&\n  scope=https%3A//www.googleapis.com/auth/drive.file&\n  redirect_uri=https%3A//oauth2.example.com/code&\n  prompt=consent&\n  include_granted_scopes=true",
            "sectionWordCount": 9
          },
          {
            "sectionTitle": "Refreshing an access token (offline access)",
            "text": "Access tokens periodically expire and become invalid credentials for a related API request. You\n  can refresh an access token without prompting the user for permission (including when the user is\n  not present) if you requested offline access to the scopes associated with the token.\n      \nIf you use a Google API Client Library, the client object refreshes\nthe access token as needed as long as you configure that object for offline access.\n\n      If you are not using a client library, you need to set the access_type HTTP\n        query parameter to offline when redirecting the user to\n        Google's OAuth 2.0 server. In that case, Google's authorization server returns a\n        refresh token when you exchange an authorization\n        code for an access token. Then, if the access token expires (or at any other time), you\n        can use a refresh token to obtain a new access token.\n    Requesting offline access is a requirement for any application that needs to access a Google\n      API when the user is not present. For example, an app that performs backup services or\n      executes actions at predetermined times needs to be able to refresh its access token when the\n      user is not present. The default style of access is called online.Server-side web applications, installed applications, and devices all obtain refresh tokens\n      during the authorization process. Refresh tokens are not typically used in client-side\n      (JavaScript) web applications.\n\n      \n\n        PHP\n\n        If your application needs offline access to a Google API, set the API client's access type to\n  offline:\n\n$client->setAccessType(\"offline\");\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\n      \n\n      \n\n        Python\n\n        In Python, set the access_type keyword argument to offline to ensure\n  that you will be able to refresh the access token without having to re-prompt the user for\n  permission. It is very possible that access_type will not be the only keyword\n  argument that you set, as shown in the example below.\n\nauthorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\n      \n\n      \n\n        Ruby\n\n        If your application needs offline access to a Google API, set the API client's access type to\n  offline:\n\nauth_client.update!(\n  :additional_parameters => {\"access_type\" => \"offline\"}\n)\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\n      \n\n      \n\n        Node.js\n\n        If your application needs offline access to a Google API, set the API client's access type to\n  offline:\n\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});\n\nAfter a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.\n\nAccess tokens expire. This library will automatically use a refresh token to obtain a new access\n  token if it is about to expire. An easy way to make sure you always store the most recent tokens\n  is to use the tokens event:\noauth2Client.on('tokens', (tokens) => {\n  if (tokens.refresh_token) {\n    // store the refresh_token in your secure persistent database\n    console.log(tokens.refresh_token);\n  }\n  console.log(tokens.access_token);\n});\nThis tokens event only occurs in the first authorization, and you need to have set your\n  access_type to offline when calling the generateAuthUrl\n  method to receive the refresh token. If you have already given your app the requisiste permissions\n  without setting the appropriate constraints for receiving a refresh token, you will need to\n  re-authorize the application to receive a fresh refresh token.\n\nTo set the refresh_token at a later time, you can use the setCredentials method:\n\noauth2Client.setCredentials({\n  refresh_token: `STORED_REFRESH_TOKEN`\n});\n\n  Once the client has a refresh token, access tokens will be acquired and refreshed automatically\n  in the next call to the API.\n\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo refresh an access token, your application sends an HTTPS POST\n  request to Google's authorization server (https://oauth2.googleapis.com/token) that\n  includes the following parameters:\n\n\n  \n    \n      Fields\n    \n  \n  \n    \n      client_id\n      The client ID obtained from the API Console.\n    \n    \n      client_secret\n      The client secret obtained from the API Console.\n        \n      \n    \n    \n      grant_type\n      As\n        defined in the\n          OAuth 2.0 specification,\n        this field's value must be set to refresh_token.\n    \n    \n      refresh_token\n      The refresh token returned from the authorization code exchange.\n    \n  \n\n\nThe following snippet shows a sample request:\n\nPOST /token HTTP/1.1\nHost: oauth2.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\nclient_id=your_client_id&\nclient_secret=your_client_secret&\nrefresh_token=refresh_token&\ngrant_type=refresh_token\n\nAs long as the user has not revoked the access granted to the application, the token server\n  returns a JSON object that contains a new access token. The following snippet shows a sample\n  response:\n\n{\n  \"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\n  \"expires_in\": 3920,\n  \"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\n  \"token_type\": \"Bearer\"\n}\n\nNote that there are limits on the number of refresh tokens that will be issued; one limit per\n  client/user combination, and another per user across all clients. You should save refresh tokens\n  in long-term storage and continue to use them as long as they remain valid. If your application\n  requests too many refresh tokens, it may run into these limits, in which case older refresh tokens\n  will stop working.\n\n      \n\n    ",
            "sectionWordCount": 962
          },
          {
            "sectionTitle": "PHP",
            "text": "If your application needs offline access to a Google API, set the API client's access type to\n  offline:$client->setAccessType(\"offline\");After a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.",
            "sectionWordCount": 58
          },
          {
            "sectionTitle": "Python",
            "text": "In Python, set the access_type keyword argument to offline to ensure\n  that you will be able to refresh the access token without having to re-prompt the user for\n  permission. It is very possible that access_type will not be the only keyword\n  argument that you set, as shown in the example below.authorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')After a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.",
            "sectionWordCount": 129
          },
          {
            "sectionTitle": "Ruby",
            "text": "If your application needs offline access to a Google API, set the API client's access type to\n  offline:auth_client.update!(\n  :additional_parameters => {\"access_type\" => \"offline\"}\n)After a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.",
            "sectionWordCount": 64
          },
          {
            "sectionTitle": "Node.js",
            "text": "If your application needs offline access to a Google API, set the API client's access type to\n  offline:const authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});After a user grants offline access to the requested scopes, you can continue to use the API\n  client to access Google APIs on the user's behalf when the user is offline. The client object\n  will refresh the access token as needed.Access tokens expire. This library will automatically use a refresh token to obtain a new access\n  token if it is about to expire. An easy way to make sure you always store the most recent tokens\n  is to use the tokens event:oauth2Client.on('tokens', (tokens) => {\n  if (tokens.refresh_token) {\n    // store the refresh_token in your secure persistent database\n    console.log(tokens.refresh_token);\n  }\n  console.log(tokens.access_token);\n});This tokens event only occurs in the first authorization, and you need to have set your\n  access_type to offline when calling the generateAuthUrl\n  method to receive the refresh token. If you have already given your app the requisiste permissions\n  without setting the appropriate constraints for receiving a refresh token, you will need to\n  re-authorize the application to receive a fresh refresh token.\nTo set the refresh_token at a later time, you can use the setCredentials method:\noauth2Client.setCredentials({\n  refresh_token: `STORED_REFRESH_TOKEN`\n});\n  Once the client has a refresh token, access tokens will be acquired and refreshed automatically\n  in the next call to the API.\n",
            "sectionWordCount": 271
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "To refresh an access token, your application sends an HTTPS POST\n  request to Google's authorization server (https://oauth2.googleapis.com/token) that\n  includes the following parameters:\n\n\n  \n    \n      Fields\n    \n  \n  \n    \n      client_id\n      The client ID obtained from the API Console.\n    \n    \n      client_secret\n      The client secret obtained from the API Console.\n        \n      \n    \n    \n      grant_type\n      As\n        defined in the\n          OAuth 2.0 specification,\n        this field's value must be set to refresh_token.\n    \n    \n      refresh_token\n      The refresh token returned from the authorization code exchange.\n    \n  \nThe following snippet shows a sample request:POST /token HTTP/1.1\nHost: oauth2.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\nclient_id=your_client_id&\nclient_secret=your_client_secret&\nrefresh_token=refresh_token&\ngrant_type=refresh_tokenAs long as the user has not revoked the access granted to the application, the token server\n  returns a JSON object that contains a new access token. The following snippet shows a sample\n  response:{\n  \"access_token\": \"1/fFAGRNJru1FTz70BzhT3Zg\",\n  \"expires_in\": 3920,\n  \"scope\": \"https://www.googleapis.com/auth/drive.metadata.readonly\",\n  \"token_type\": \"Bearer\"\n}Note that there are limits on the number of refresh tokens that will be issued; one limit per\n  client/user combination, and another per user across all clients. You should save refresh tokens\n  in long-term storage and continue to use them as long as they remain valid. If your application\n  requests too many refresh tokens, it may run into these limits, in which case older refresh tokens\n  will stop working.",
            "sectionWordCount": 194
          },
          {
            "sectionTitle": "Revoking a token",
            "text": "In some cases a user may wish to revoke access given to an application. A user can revoke access\n  by visiting \n  Account Settings. See the\n  Remove\n    site or app access section of the Third-party sites & apps with access to your account\n  support document for more information.It is also possible for an application to programmatically revoke the access given to it.\n  Programmatic revocation is important in instances where a user unsubscribes, removes an\n  application, or the API resources required by an app have significantly changed. In other words,\n  part of the removal process can include an API request to ensure the permissions previously\n  granted to the application are removed.\n\n      \n\n        PHP\n\n        To programmatically revoke a token, call revokeToken():\n\n$client->revokeToken();\n\n      \n\n      \n\n        Python\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo programmatically revoke a token, make a request to\n  https://oauth2.googleapis.com/revoke that includes the token as a parameter and sets the\n  Content-Type header:\n\nrequests.post('https://oauth2.googleapis.com/revoke',\n    params={'token': credentials.token},\n    headers = {'content-type': 'application/x-www-form-urlencoded'})\n\n      \n\n      \n\n        Ruby\n\n        To programmatically revoke a token, make an HTTP request to the oauth2.revoke\n  endpoint:\n\nuri = URI('https://oauth2.googleapis.com/revoke')\nresponse = Net::HTTP.post_form(uri, 'token' => auth_client.access_token)\n\nThe token can be an access token or a refresh token. If the token is an access token and it has\n  a corresponding refresh token, the refresh token will also be revoked.\n\nIf the revocation is successfully processed, then the status code of the response is\n  200. For error conditions, a status code 400 is returned along with an\n  error code.\n\n      \n\n      \n\n        Node.js\n\n        To programmatically revoke a token, make an HTTPS POST request to /revoke\n  endpoint:\n\nconst https = require('https');\n\n// Build the string for the POST request\nlet postData = \"token=\" + userCredential.access_token;\n\n// Options for POST request to Google's OAuth 2.0 server to revoke a token\nlet postOptions = {\n  host: 'oauth2.googleapis.com',\n  port: '443',\n  path: '/revoke',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n};\n\n// Set up the request\nconst postReq = https.request(postOptions, function (res) {\n  res.setEncoding('utf8');\n  res.on('data', d => {\n    console.log('Response: ' + d);\n  });\n});\n\npostReq.on('error', error => {\n  console.log(error)\n});\n\n// Post the request with data\npostReq.write(postData);\npostReq.end();\n\nThe token parameter can be an access token or a refresh token. If the token is an access token and it has\n  a corresponding refresh token, the refresh token will also be revoked.\n\nIf the revocation is successfully processed, then the status code of the response is\n  200. For error conditions, a status code 400 is returned along with an\n  error code.\n\n      \n\n      \n\n        HTTP/REST\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo programmatically revoke a token, your application makes a request to\nhttps://oauth2.googleapis.com/revoke and includes the token as a parameter:\n\ncurl -d -X -POST --header \"Content-type:application/x-www-form-urlencoded\" \\\n        https://oauth2.googleapis.com/revoke?token={token}\n\nThe token can be an access token or a refresh token. If the token is an access token and it has a\n  corresponding refresh token, the refresh token will also be revoked.\n\n\n\nIf the revocation is successfully processed, then the HTTP status code of the response is\n  200. For error conditions, an HTTP status code 400 is returned along\n  with an error code.\n\n\n\n      \n\n    Note: Following a successful revocation response, it might take some\n  time before the revocation has full effect.\n      Implementing Cross-Account Protection\n\n      \n  An additional step you should take to protect your users' accounts is implementing Cross-Account\n  Protection by utilizing Google's Cross-Account Protection Service. This service lets you\n  subscribe to security event notifications which provide information to your application about\n  major changes to the user account. You can then use the information to take action depending on\n  how you decide to respond to events.\n\n\n  Some examples of the event types sent to your app by Google's Cross-Account Protection Service are:\n\n\n  \n    https://schemas.openid.net/secevent/risc/event-type/sessions-revoked\n  \n  \n    https://schemas.openid.net/secevent/oauth/event-type/token-revoked\n  \n  \n    https://schemas.openid.net/secevent/risc/event-type/account-disabled\n  \n\n\n  See the\n  \n    Protect user accounts with Cross-Account Protection page\n  \n  for more information on how to implement Cross Account Protection and for the full list of available events.\n\n    ",
            "sectionWordCount": 615
          },
          {
            "sectionTitle": "PHP",
            "text": "To programmatically revoke a token, call revokeToken():$client->revokeToken();",
            "sectionWordCount": 7
          },
          {
            "sectionTitle": "Python",
            "text": "To programmatically revoke a token, make a request to\n  https://oauth2.googleapis.com/revoke that includes the token as a parameter and sets the\n  Content-Type header:requests.post('https://oauth2.googleapis.com/revoke',\n    params={'token': credentials.token},\n    headers = {'content-type': 'application/x-www-form-urlencoded'})",
            "sectionWordCount": 28
          },
          {
            "sectionTitle": "Ruby",
            "text": "To programmatically revoke a token, make an HTTP request to the oauth2.revoke\n  endpoint:uri = URI('https://oauth2.googleapis.com/revoke')\nresponse = Net::HTTP.post_form(uri, 'token' => auth_client.access_token)The token can be an access token or a refresh token. If the token is an access token and it has\n  a corresponding refresh token, the refresh token will also be revoked.If the revocation is successfully processed, then the status code of the response is\n  200. For error conditions, a status code 400 is returned along with an\n  error code.",
            "sectionWordCount": 80
          },
          {
            "sectionTitle": "Node.js",
            "text": "To programmatically revoke a token, make an HTTPS POST request to /revoke\n  endpoint:const https = require('https');\n\n// Build the string for the POST request\nlet postData = \"token=\" + userCredential.access_token;\n\n// Options for POST request to Google's OAuth 2.0 server to revoke a token\nlet postOptions = {\n  host: 'oauth2.googleapis.com',\n  port: '443',\n  path: '/revoke',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n};\n\n// Set up the request\nconst postReq = https.request(postOptions, function (res) {\n  res.setEncoding('utf8');\n  res.on('data', d => {\n    console.log('Response: ' + d);\n  });\n});\n\npostReq.on('error', error => {\n  console.log(error)\n});\n\n// Post the request with data\npostReq.write(postData);\npostReq.end();The token parameter can be an access token or a refresh token. If the token is an access token and it has\n  a corresponding refresh token, the refresh token will also be revoked.If the revocation is successfully processed, then the status code of the response is\n  200. For error conditions, a status code 400 is returned along with an\n  error code.",
            "sectionWordCount": 161
          },
          {
            "sectionTitle": "HTTP/REST",
            "text": "To programmatically revoke a token, your application makes a request to\nhttps://oauth2.googleapis.com/revoke and includes the token as a parameter:curl -d -X -POST --header \"Content-type:application/x-www-form-urlencoded\" \\\n        https://oauth2.googleapis.com/revoke?token={token}The token can be an access token or a refresh token. If the token is an access token and it has a\n  corresponding refresh token, the refresh token will also be revoked.If the revocation is successfully processed, then the HTTP status code of the response is\n  200. For error conditions, an HTTP status code 400 is returned along\n  with an error code.",
            "sectionWordCount": 87
          },
          {
            "sectionTitle": "Implementing Cross-Account Protection",
            "text": "\n  An additional step you should take to protect your users' accounts is implementing Cross-Account\n  Protection by utilizing Google's Cross-Account Protection Service. This service lets you\n  subscribe to security event notifications which provide information to your application about\n  major changes to the user account. You can then use the information to take action depending on\n  how you decide to respond to events.\n\n  Some examples of the event types sent to your app by Google's Cross-Account Protection Service are:\n\n  \n    https://schemas.openid.net/secevent/risc/event-type/sessions-revoked\n  \n  \n    https://schemas.openid.net/secevent/oauth/event-type/token-revoked\n  \n  \n    https://schemas.openid.net/secevent/risc/event-type/account-disabled\n  \n\n  See the\n  \n    Protect user accounts with Cross-Account Protection page\n  \n  for more information on how to implement Cross Account Protection and for the full list of available events.\n",
            "sectionWordCount": 107
          },
          {
            "sectionTitle": "Product Info",
            "text": "\n        \n        \n          \n          \n            \n          \n            Terms of Service\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            APIs User Data Policy\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n              \n              \n            \n          \n            Branding Guidelines\n          \n          \n          \n          \n        \n        \n      ",
            "sectionWordCount": 9
          },
          {
            "sectionTitle": "Stack Overflow",
            "text": "\n        \n        \n          \n          \n            \n          \n            Google Identity\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Sign In With Google\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Google OAuth 2.0 and OpenID Connect\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n              \n              \n            \n          \n            Google Account Linking\n          \n          \n          \n          \n        \n        \n      ",
            "sectionWordCount": 15
          },
          {
            "sectionTitle": "Developer consoles",
            "text": "\n        \n        \n          \n          \n            \n          \n            Google API Console\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Google Cloud Platform Console\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Google Play Console\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Firebase Console\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Actions on Google Console\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Cast SDK Developer Console\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n          \n            Chrome Web Store Dashboard\n          \n          \n          \n          \n        \n        \n        \n          \n          \n            \n              \n              \n            \n          \n            Google Home Developer Console\n          \n          \n          \n          \n        \n        \n      ",
            "sectionWordCount": 28
          }
        ]
      },
      "userExperience": {
        "mobileFriendly": true,
        "coreWebVitals": {
          "largestContentfulPaintMs": 8470,
          "firstInputDelayMs": 0,
          "cumulativeLayoutShift": 0.81
        },
        "accessibility": {
          "hasAltText": true,
          "metaViewportTagPresent": true,
          "colorContrastScore": 50,
          "keyboardNavigation": "partially supported"
        },
        "popupsOrInterruption": {
          "hasIntrusivePopups": false,
          "popupTypes": []
        }
      },
      "pageSpeed": {
        "fetchTimeMs": 0,
        "htmlSizeKb": 362,
        "resourceCount": 13,
        "timeToInteractiveMs": 500,
        "firstContentfulPaintMs": 100,
        "imageOptimizationScore": 100
      },
      "metadata": {
        "title": "Using OAuth 2.0 for Web Server Applications  |  Authorization  |  Google for DevelopersGoogleGoogle",
        "metaDescription": "",
        "titleLength": 103,
        "metaDescriptionLength": 0
      },
      "internalLinking": {
        "links": [
          {
            "href": "https://developers.google.com/identity",
            "anchorText": "Google Identity",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/authentication",
            "anchorText": "Authentication",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#",
            "anchorText": "",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/android-credential-manager",
            "anchorText": "Credential Manager for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/gsi/web/guides/overview",
            "anchorText": "Sign In with Google for Web (including One Tap)",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/sign-in/ios/start",
            "anchorText": "Google Sign-In for iOS and macOS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/passkeys",
            "anchorText": "Passkeys",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/openid-connect/openid-connect",
            "anchorText": "OpenID Connect",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/one-tap/android/overview",
            "anchorText": "One Tap sign-up/sign-in for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/sign-in/android/legacy-start-integrating",
            "anchorText": "Google Sign-In for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/sign-in/web/sign-in",
            "anchorText": "Google Sign-In for Web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/authorization",
            "anchorText": "Authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#",
            "anchorText": "",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/sign-in/android/authorize-access",
            "anchorText": "Authorizing for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/oauth2/web/guides/overview",
            "anchorText": "Authorizing for Web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/sign-in/ios/api-access",
            "anchorText": "Authorizing for iOS/macOS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/protocols/oauth2",
            "anchorText": "Using OAuth 2.0",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/account-linking",
            "anchorText": "Google Account Linking",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/credential-management",
            "anchorText": "Credential management",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#",
            "anchorText": "",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/android-credential-manager",
            "anchorText": "Credential Manager",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/blockstore/android",
            "anchorText": "Blockstore",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/smartlock-passwords/android/associate-apps-and-sites",
            "anchorText": "Digital Asset Links",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.android.com/guide/topics/text/autofill",
            "anchorText": "Android autofill framework",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://web.dev/sign-in-form-best-practices/",
            "anchorText": "Autocomplete",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/credential-sharing",
            "anchorText": "Seamless credential sharing",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/credential-verification",
            "anchorText": "Credential verification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#",
            "anchorText": "",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/sms-retriever/overview",
            "anchorText": "Verify users by SMS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/phone-number-hint/android",
            "anchorText": "Phone Number Hint",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://web.dev/web-otp/",
            "anchorText": "Verify phone numbers on the web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "English",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Deutsch",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Español",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Español – América Latina",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Français",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Indonesia",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Italiano",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Polski",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Português – Brasil",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Tiếng Việt",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Türkçe",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Русский",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "עברית",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "العربيّة",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "فارسی",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "हिंदी",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "বাংলা",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "ภาษาไทย",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "中文 – 简体",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "中文 – 繁體",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "日本語",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "한국어",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/authorization",
            "anchorText": "Authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/protocols/oauth2",
            "anchorText": "OAuth 2.0",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/authorization/android",
            "anchorText": "Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/oauth2/web/guides/overview",
            "anchorText": "Web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/account-linking",
            "anchorText": "Google Account Linking",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity",
            "anchorText": "Google Identity",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/authentication",
            "anchorText": "Authentication",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/authorization",
            "anchorText": "Authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2",
            "anchorText": "OAuth 2.0",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/authorization/android",
            "anchorText": "Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/oauth2/web/guides/overview",
            "anchorText": "Web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/account-linking",
            "anchorText": "Google Account Linking",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/credential-management",
            "anchorText": "Credential management",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/credential-verification",
            "anchorText": "Credential verification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2",
            "anchorText": "Overview",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/cross-client-identity",
            "anchorText": "Cross-client Identity",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/scopes",
            "anchorText": "OAuth 2.0 Scopes",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/policies",
            "anchorText": "OAuth 2.0 Policies",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/web-server",
            "anchorText": "for Server-side Web Apps",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/javascript-implicit-flow",
            "anchorText": "for JavaScript Web Apps",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/native-app",
            "anchorText": "for Mobile & Desktop Apps",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/limited-input-device",
            "anchorText": "for TV & Device Apps",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/service-account",
            "anchorText": "for Service Accounts",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/production-readiness/policy-compliance",
            "anchorText": "Comply with OAuth 2.0 policies",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/production-readiness/brand-verification",
            "anchorText": "Submit for brand verification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/production-readiness/sensitive-scope-verification",
            "anchorText": "Sensitive scope verification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/production-readiness/restricted-scope-verification",
            "anchorText": "Restricted scope verification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/production-readiness/google-workspace",
            "anchorText": "Additional considerations for Google Workspace",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/resources/best-practices",
            "anchorText": "Best practices",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/resources/granular-permissions",
            "anchorText": "How to handle granular permissions",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/resources/oob-migration",
            "anchorText": "Out-of-band (OOB) Migration",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/resources/loopback-migration",
            "anchorText": "Loopback IP Address Migration for Mobile and Chrome Apps",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/risc",
            "anchorText": "Cross-Account Protection (RISC)",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://webauthn.guide/",
            "anchorText": "WebAuthn",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/android-credential-manager",
            "anchorText": "Credential Manager for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/gsi/web/guides/overview",
            "anchorText": "Sign In with Google for Web (including One Tap)",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sign-in/ios/start",
            "anchorText": "Google Sign-In for iOS and macOS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/passkeys",
            "anchorText": "Passkeys",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/openid-connect/openid-connect",
            "anchorText": "OpenID Connect",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/one-tap/android/overview",
            "anchorText": "One Tap sign-up/sign-in for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sign-in/android/legacy-start-integrating",
            "anchorText": "Google Sign-In for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sign-in/web/sign-in",
            "anchorText": "Google Sign-In for Web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sign-in/android/authorize-access",
            "anchorText": "Authorizing for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/oauth2/web/guides/overview",
            "anchorText": "Authorizing for Web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sign-in/ios/api-access",
            "anchorText": "Authorizing for iOS/macOS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2",
            "anchorText": "Using OAuth 2.0",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/account-linking",
            "anchorText": "Google Account Linking",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/android-credential-manager",
            "anchorText": "Credential Manager",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/blockstore/android",
            "anchorText": "Blockstore",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/smartlock-passwords/android/associate-apps-and-sites",
            "anchorText": "Digital Asset Links",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.android.com/guide/topics/text/autofill",
            "anchorText": "Android autofill framework",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://web.dev/sign-in-form-best-practices/",
            "anchorText": "Autocomplete",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/credential-sharing",
            "anchorText": "Seamless credential sharing",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sms-retriever/overview",
            "anchorText": "Verify users by SMS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/phone-number-hint/android",
            "anchorText": "Phone Number Hint",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://web.dev/web-otp/",
            "anchorText": "Verify phone numbers on the web",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/",
            "anchorText": "Home",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/products",
            "anchorText": "Products",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity",
            "anchorText": "Google Identity",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/authorization",
            "anchorText": "Authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/protocols/oauth2",
            "anchorText": "OAuth 2.0",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/service-account",
            "anchorText": "service accounts",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#libraries",
            "anchorText": "Client libraries",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/api-client-library",
            "anchorText": "Google API Client Libraries",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-go-client",
            "anchorText": "Go",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/api-client-library/java",
            "anchorText": "Java",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/api-client-library/dotnet",
            "anchorText": ".NET",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-nodejs-client",
            "anchorText": "Node.js",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-php-client",
            "anchorText": "PHP",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-python-client",
            "anchorText": "Python",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-ruby-client",
            "anchorText": "Ruby",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/api-client-library/javascript",
            "anchorText": "Google API client library for JavaScript",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/gsi/web/guides/overview",
            "anchorText": "Sign In With Google",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-nodejs-client",
            "anchorText": "Node.js",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/library",
            "anchorText": "Open the API Library",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/credentials",
            "anchorText": "Credentials page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#uri-validation",
            "anchorText": "Google’s validation rules",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#protectauthcode",
            "anchorText": "design your app's auth endpoints",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#incrementalAuth",
            "anchorText": "incremental authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/scopes",
            "anchorText": "OAuth 2.0 API Scopes",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://support.google.com/cloud/answer/7454865",
            "anchorText": "unverified apps",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://support.google.com/cloud/answer/9110914",
            "anchorText": "frequently asked questions about app verification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://getcomposer.org/",
            "anchorText": "Composer",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://pypi.org/project/pip/",
            "anchorText": "pip",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#creatingcred",
            "anchorText": "creating authorization credentials",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#creatingcred",
            "anchorText": "creating authorization credentials",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-nodejs-client/issues/750#issuecomment-304521450",
            "anchorText": "here",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/credentials",
            "anchorText": "Credentials page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/credentials",
            "anchorText": "Credentials page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#incrementalAuth",
            "anchorText": "incremental authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://datatracker.ietf.org/doc/html/rfc6749#section-10.12",
            "anchorText": "cross-site request forgery",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/openid-connect#createxsrftoken",
            "anchorText": "OpenID Connect",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://datatracker.ietf.org/doc/html/rfc6749#section-10.12",
            "anchorText": "OAuth2 Specification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#incrementalAuth",
            "anchorText": "incremental authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/resources/granular-permissions",
            "anchorText": "more granular Google Account permissions",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/openid-connect#re-consent",
            "anchorText": "Prompting re-consent",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#incrementalAuth",
            "anchorText": "incremental authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#creatingclient",
            "anchorText": "Step 1",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://support.google.com/a/answer/7281227",
            "anchorText": "Control which third-party & internal apps access Google Workspace data",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/policies#browsers",
            "anchorText": "OAuth 2.0 Policies",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.android.com/reference/android/webkit/WebView",
            "anchorText": "android.webkit.WebView",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sign-in/android",
            "anchorText": "Google Sign-In for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://openid.github.io/AppAuth-Android/",
            "anchorText": "AppAuth for Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.android.com/training/app-links",
            "anchorText": "Android App Links",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.chrome.com/docs/android/custom-tabs/overview/",
            "anchorText": "Android Custom Tabs",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.apple.com/documentation/webkit/wkwebview",
            "anchorText": "WKWebView",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/sign-in/ios",
            "anchorText": "Google Sign-In for iOS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://openid.github.io/AppAuth-iOS/",
            "anchorText": "AppAuth for iOS",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.apple.com/ios/universal-links/",
            "anchorText": "Universal Links",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller",
            "anchorText": "SFSafariViewController",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy#organizations",
            "anchorText": "Google Cloud Organization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://support.google.com/cloud/answer/10311615#user-type",
            "anchorText": "User type",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/javascript-implicit-flow#creatingcred",
            "anchorText": "OAuth client configuration",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#offline",
            "anchorText": "When refreshing an access token",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#incrementalAuth",
            "anchorText": "incremental authorization",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/credentials",
            "anchorText": "Credentials page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/protocols/oauth2/resources/oob-migration",
            "anchorText": "migration guide",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://datatracker.ietf.org/doc/html/rfc6749#section-10.12",
            "anchorText": "CSRF attacks",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://accounts.google.com/o/oauth2/v2/auth?scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly&state=state_parameter_passthrough_value&redirect_uri=https%3A//oauth2.example.com/code&access_type=offline&response_type=code&client_id=583306224539-atbcaa8ne8g85e8kc006o6vmq99qiid0.apps.googleusercontent.com",
            "anchorText": "https://accounts.google.com/o/oauth2/v2/auth? scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly& access_type=offline& include_granted_scopes=true& response_type=code& state=state_parameter_passthrough_value& redirect_uri=https%3A//oauth2.example.com/code& client_id=client_id",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/credentials",
            "anchorText": "Credentials page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/credentials",
            "anchorText": "Credentials page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc6749#section-4.1.3",
            "anchorText": "As defined in the OAuth 2.0 specification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/apis/credentials",
            "anchorText": "Credentials page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#creatingclient",
            "anchorText": "the initial request to Google's authorization server",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#creatingclient",
            "anchorText": "restarting the OAuth process",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-php-client/blob/master/docs/start.md",
            "anchorText": "interface provided by the service object",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-python-client/blob/master/docs/start.md#building-and-calling-a-service",
            "anchorText": "interface provided by the service object",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-ruby-client",
            "anchorText": "interface provided by the service object",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/drive/api/v2/reference#Files",
            "anchorText": "calling the Drive Files API",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/oauthplayground/",
            "anchorText": "OAuth 2.0 Playground",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/drive/v2/reference/files/list",
            "anchorText": "drive.files",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-php-client",
            "anchorText": "Google API Client Library",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://getcomposer.org/",
            "anchorText": "Composer",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://palletsprojects.com/p/flask/",
            "anchorText": "Flask",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#redirecting",
            "anchorText": "authorization flow",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#tokenrevoke",
            "anchorText": "revokes",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#prerequisites",
            "anchorText": "prerequisites",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "http://www.sinatrarb.com/",
            "anchorText": "Sinatra",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://github.com/googleapis/google-api-nodejs-client",
            "anchorText": "Google API Client Library",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://www.npmjs.com/",
            "anchorText": "npm",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://palletsprojects.com/p/flask/",
            "anchorText": "Flask",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://requests.readthedocs.io/",
            "anchorText": "Requests",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc3986#section-3",
            "anchorText": "RFC 3986 section 3",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc3986#section-3.1",
            "anchorText": "Scheme",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc3986#section-3.2.2",
            "anchorText": "Host",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc1034",
            "anchorText": "Domain",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/id/draft-liman-tld-names-00.html",
            "anchorText": "Top Level Domains",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://publicsuffix.org/list/",
            "anchorText": "public suffix list",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc3986#section-3.2.1",
            "anchorText": "Userinfo",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc3986#section-3.3",
            "anchorText": "Path",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc3986#section-3.4",
            "anchorText": "Query",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc6749#section-10.15",
            "anchorText": "open redirects",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc3986#section-3.5",
            "anchorText": "Fragment",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://support.google.com/cloud/answer/7454865",
            "anchorText": "Unverified apps",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#creatingclient",
            "anchorText": "Step 1: Set authorization parameters",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#redirecting",
            "anchorText": "Step 2: Redirect to Google's OAuth 2.0 server",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#creatingclient",
            "anchorText": "client object",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#redirecting",
            "anchorText": "redirecting the user to Google's OAuth 2.0 server",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#exchange-authorization-code",
            "anchorText": "exchange an authorization code",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/",
            "anchorText": "API Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://console.developers.google.com/",
            "anchorText": "API Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://tools.ietf.org/html/rfc6749#section-6",
            "anchorText": "defined in the OAuth 2.0 specification",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://myaccount.google.com/permissions",
            "anchorText": "Account Settings",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://support.google.com/accounts/answer/3466521#remove-access",
            "anchorText": "Remove site or app access section of the Third-party sites & apps with access to your account",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/identity/protocols/risc",
            "anchorText": "Protect user accounts with Cross-Account Protection page",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://creativecommons.org/licenses/by/4.0/",
            "anchorText": "Creative Commons Attribution 4.0 License",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://www.apache.org/licenses/LICENSE-2.0",
            "anchorText": "Apache 2.0 License",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/site-policies",
            "anchorText": "Google Developers Site Policies",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//github.com/googlesamples",
            "anchorText": "GitHub",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//stackoverflow.com/questions/tagged/google-oauth",
            "anchorText": "Stack Overflow",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//googledevelopers.blogspot.com/search/label/oauth",
            "anchorText": "Blog",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/terms",
            "anchorText": "Terms of Service",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/terms/api-services-user-data-policy",
            "anchorText": "APIs User Data Policy",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/identity/branding-guidelines",
            "anchorText": "Branding Guidelines",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://stackoverflow.com/questions/tagged/google-identity",
            "anchorText": "Google Identity",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//stackoverflow.com/questions/tagged/google-signin",
            "anchorText": "Sign In With Google",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://stackoverflow.com/questions/tagged/google-oauth",
            "anchorText": "Google OAuth 2.0 and OpenID Connect",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//stackoverflow.com/questions/tagged/account-linking",
            "anchorText": "Google Account Linking",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//console.developers.google.com",
            "anchorText": "Google API Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//console.cloud.google.com",
            "anchorText": "Google Cloud Platform Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//play.google.com/apps/publish",
            "anchorText": "Google Play Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//console.firebase.google.com",
            "anchorText": "Firebase Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//console.actions.google.com",
            "anchorText": "Actions on Google Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//cast.google.com/publish",
            "anchorText": "Cast SDK Developer Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//chrome.google.com/webstore/developer/dashboard",
            "anchorText": "Chrome Web Store Dashboard",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//console.home.google.com",
            "anchorText": "Google Home Developer Console",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "https://developers.google.com/",
            "anchorText": "",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//developer.android.com",
            "anchorText": "Android",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//developer.chrome.com/home",
            "anchorText": "Chrome",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//firebase.google.com",
            "anchorText": "Firebase",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//cloud.google.com",
            "anchorText": "Google Cloud Platform",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//ai.google.dev/",
            "anchorText": "Google AI",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/products",
            "anchorText": "All products",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/terms/site-terms",
            "anchorText": "Terms",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "//policies.google.com/privacy",
            "anchorText": "Privacy",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "#",
            "anchorText": "Manage cookies",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "/newsletter/subscribe",
            "anchorText": "Subscribe",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "English",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Deutsch",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Español",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Español – América Latina",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Français",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Indonesia",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Italiano",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Polski",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Português – Brasil",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Tiếng Việt",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Türkçe",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "Русский",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "עברית",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "العربيّة",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "فارسی",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "हिंदी",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "বাংলা",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "ภาษาไทย",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "中文 – 简体",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "中文 – 繁體",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "日本語",
            "linkType": "follow",
            "context": "Main Content"
          },
          {
            "href": "",
            "anchorText": "한국어",
            "linkType": "follow",
            "context": "Main Content"
          }
        ],
        "averageInternalLinksPerPage": 272
      }
    },
    "mediumPriority": {
      "backlinkProfile": {
        "numberOfBacklinks": 50,
        "referringDomains": 20,
        "averageDomainAuthority": 60,
        "nofollowLinksRatio": 0.2
      },
      "structuredData": [
        {
          "type": "BreadcrumbList",
          "properties": {
            "itemListElement": [
              {
                "item": "https://developers.google.com/identity",
                "name": "Google Identity",
                "position": 1
              },
              {
                "item": "https://developers.google.com/identity/authorization",
                "name": "Authorization",
                "position": 2
              },
              {
                "item": "https://developers.google.com/identity/protocols/oauth2/web-server",
                "name": "Using OAuth 2.0 for Web Server Applications",
                "position": 3
              }
            ]
          }
        }
      ],
      "socialSignals": {
        "numberOfShares": {
          "facebook": 100,
          "twitter": 50,
          "linkedin": 30
        },
        "engagementRate": 0.05
      },
      "contentFreshness": {
        "lastUpdatedDate": "Unknown",
        "updateFrequency": "Unknown"
      }
    },
    "lowPriority": {
      "openGraphTags": {
        "ogTitle": "Using OAuth 2.0 for Web Server Applications  |  Authorization  |  Google for Developers",
        "ogDescription": "",
        "ogImage": "https://www.gstatic.com/devrel-devsite/prod/v1d4a4bce9a6f1ad12c0dbb886d406b5bcfdf3882f3026512eb5f609d55157b5b/developers/images/opengraph/teal.png"
      },
      "twitterCards": {
        "cardType": "summary_large_image",
        "title": "",
        "description": "",
        "image": ""
      }
    }
  },
  "technicalSEO": {
    "urlStructure": {
      "isClean": true,
      "containsKeywords": true,
      "length": 37,
      "httpsEnabled": true
    },
    "schemaMarkup": [
      {
        "type": "BreadcrumbList",
        "properties": {
          "itemListElement": [
            {
              "item": "https://developers.google.com/identity",
              "name": "Google Identity",
              "position": 1
            },
            {
              "item": "https://developers.google.com/identity/authorization",
              "name": "Authorization",
              "position": 2
            },
            {
              "item": "https://developers.google.com/identity/protocols/oauth2/web-server",
              "name": "Using OAuth 2.0 for Web Server Applications",
              "position": 3
            }
          ]
        }
      }
    ]
  },
  "content": {
    "plainText": "- Google Identity Authentication - Sign In with Google SDKs - Credential Manager for Android - Sign In with Google for Web (including One Tap) - Google Sign-In for iOS and macOS - Industry standards - Passkeys - OpenID Connect - Legacy Sign In - One Tap sign-up/sign-in for Android - Google Sign-In for Android - Google Sign-In for Web Authorization - Call Google APIs - Authorizing for Android - Authorizing for Web - Authorizing for iOS/macOS - Using OAuth 2.0 - Share data with Google apps and devices - Google Account Linking Credential management - Android - Credential Manager - Blockstore - Digital Asset Links - Android autofill framework - Web - Autocomplete - Cross-platform - Seamless credential sharing Credential verification - Android - Verify users by SMS - Phone Number Hint - Web - Verify phone numbers on the web / - English - Deutsch - Español - Español – América Latina - Français - Indonesia - Italiano - Polski - Português – Brasil - Tiếng Việt - Türkçe - Русский - עברית - العربيّة - فارسی - हिंदी - বাংলা - ภาษาไทย - 中文 – 简体 - 中文 – 繁體 - 日本語 - 한국어 Sign in - Authorization OAuth 2.0 Android Web Google Account Linking - Google Identity - Authentication - More - Authorization - More - OAuth 2.0 - Android - Web - Google Account Linking - Credential management - More - Credential verification - More - Overview - Cross-client Identity - OAuth 2.0 Scopes - OAuth 2.0 Policies - Access to Google APIs - for Server-side Web Apps - for JavaScript Web Apps - for Mobile & Desktop Apps - for TV & Device Apps - for Service Accounts - Prepare your app for production - Comply with OAuth 2.0 policies - Submit for brand verification - Sensitive scope verification - Restricted scope verification - Additional considerations for Google Workspace - Resources - Best practices - How to handle granular permissions - Out-of-band (OOB) Migration - Loopback IP Address Migration for Mobile and Chrome Apps - Related topics - Cross-Account Protection (RISC) - WebAuthn - Sign In with Google SDKs - Credential Manager for Android - Sign In with Google for Web (including One Tap) - Google Sign-In for iOS and macOS - Industry standards - Passkeys - OpenID Connect - Legacy Sign In - One Tap sign-up/sign-in for Android - Google Sign-In for Android - Google Sign-In for Web - Call Google APIs - Authorizing for Android - Authorizing for Web - Authorizing for iOS/macOS - Using OAuth 2.0 - Share data with Google apps and devices - Google Account Linking - Android - Credential Manager - Blockstore - Digital Asset Links - Android autofill framework - Web - Autocomplete - Cross-platform - Seamless credential sharing - Android - Verify users by SMS - Phone Number Hint - Web - Verify phone numbers on the web - Home - Products - Google Identity - Authorization - OAuth 2.0 Send feedback Using OAuth 2.0 for Web Server Applications Stay organized with collections Save and categorize content based on your preferences. This document explains how web server applications use Google API Client Libraries or Google OAuth 2.0 endpoints to implement OAuth 2.0 authorization to access Google APIs. OAuth 2.0 allows users to share specific data with an application while keeping their usernames, passwords, and other information private. For example, an application can use OAuth 2.0 to obtain permission from users to store files in their Google Drives. This OAuth 2.0 flow is specifically for user authorization. It is designed for applications that can store confidential information and maintain state. A properly authorized web server application can access an API while the user interacts with the application or after the user has left the application. Web server applications frequently also use service accounts to authorize API requests, particularly when calling Cloud APIs to access project-based data rather than user-specific data. Web server applications can use service accounts in conjunction with user authorization. Note: Given the security implications of getting the implementation correct, we strongly encourage you to use OAuth 2.0 libraries when interacting with Google's OAuth 2.0 endpoints. It is a best practice to use well-debugged code provided by others, and it will help you protect yourself and your users. For more information, see Client libraries . Client libraries The language-specific examples on this page use Google API Client Libraries to implement OAuth 2.0 authorization. To run the code samples, you must first install the client library for your language. When you use a Google API Client Library to handle your application's OAuth 2.0 flow, the client library performs many actions that the application would otherwise need to handle on its own. For example, it determines when the application can use or refresh stored access tokens as well as when the application must reacquire consent. The client library also generates correct redirect URLs and helps to implement redirect handlers that exchange authorization codes for access tokens. Google API Client Libraries for server-side applications are available for the following languages: - Go - Java - .NET - Node.js - PHP - Python - Ruby Important: The Google API client library for JavaScript and Sign In With Google are only intended to handle OAuth 2.0 in the user's browser. If you want to use JavaScript on the server-side to manage OAuth 2.0 interactions with Google, consider using the Node.js library on your back-end platform. Prerequisites Enable APIs for your project Any application that calls Google APIs needs to enable those APIs in the API Console. To enable an API for your project: - Open the API Library in the Google API Console. - If prompted, select a project, or create a new one. - The API Library lists all available APIs, grouped by product family and popularity. If the API you want to enable isn't visible in the list, use search to find it, or click View All in the product family it belongs to. - Select the API you want to enable, then click the Enable button. - If prompted, enable billing. - If prompted, read and accept the API's Terms of Service. Create authorization credentials Any application that uses OAuth 2.0 to access Google APIs must have authorization credentials that identify the application to Google's OAuth 2.0 server. The following steps explain how to create credentials for your project. Your applications can then use the credentials to access APIs that you have enabled for that project. - Go to the Credentials page . - Click Create credentials > OAuth client ID . - Select the Web application application type. - Fill in the form and click Create . Applications that use languages and frameworks like PHP, Java, Python, Ruby, and .NET must specify authorized redirect URIs . The redirect URIs are the endpoints to which the OAuth 2.0 server can send responses. These endpoints must adhere to Google’s validation rules . For testing, you can specify URIs that refer to the local machine, such as http://localhost:8080 . With that in mind, please note that all of the examples in this document use http://localhost:8080 as the redirect URI. We recommend that you design your app's auth endpoints so that your application does not expose authorization codes to other resources on the page. After creating your credentials, download the client_secret.json file from the API Console. Securely store the file in a location that only your application can access. Important: Do not store the client_secret.json file in a publicly-accessible location. In addition, if you share the source code to your application — for example, on GitHub — store the client_secret.json file outside of your source tree to avoid inadvertently sharing your client credentials. Identify access scopes Scopes enable your application to only request access to the resources that it needs while also enabling users to control the amount of access that they grant to your application. Thus, there may be an inverse relationship between the number of scopes requested and the likelihood of obtaining user consent. Before you start implementing OAuth 2.0 authorization, we recommend that you identify the scopes that your app will need permission to access. We also recommend that your application request access to authorization scopes via an incremental authorization process, in which your application requests access to user data in context. This best practice helps users to more easily understand why your application needs the access it is requesting. The OAuth 2.0 API Scopes document contains a full list of scopes that you might use to access Google APIs. If your public application uses scopes that permit access to certain user data, it must complete a verification process. If you see unverified app on the screen when testing your application, you must submit a verification request to remove it. Find out more about unverified apps and get answers to frequently asked questions about app verification in the Help Center. Language-specific requirements To run any of the code samples in this document, you'll need a Google account, access to the Internet, and a web browser. If you are using one of the API client libraries, also see the language-specific requirements below. PHP To run the PHP code samples in this document, you'll need: - PHP 5.6 or greater with the command-line interface (CLI) and JSON extension installed. - The Composer dependency management tool. - The Google APIs Client Library for PHP: composer require google/apiclient:^2.10 Python To run the Python code samples in this document, you'll need: - Python 2.6 or greater - The pip package management tool. - The Google APIs Client Library for Python: pip install --upgrade google-api-python-client - The google-auth , google-auth-oauthlib , and google-auth-httplib2 for user authorization. pip install --upgrade google-auth google-auth-oauthlib google-auth-httplib2 - The Flask Python web application framework. pip install --upgrade flask - The requests HTTP library. pip install --upgrade requests Ruby To run the Ruby code samples in this document, you'll need: - Ruby 2.6 or greater - The Google Auth Library for Ruby: gem install googleauth - The Sinatra Ruby web application framework. gem install sinatra Node.js To run the Node.js code samples in this document, you'll need: - The maintenance LTS, active LTS, or current release of Node.js. - The Google APIs Node.js Client: npm install googleapis crypto express express-session HTTP/REST You do not need to install any libraries to be able to directly call the OAuth 2.0 endpoints. Obtaining OAuth 2.0 access tokens The following steps show how your application interacts with Google's OAuth 2.0 server to obtain a user's consent to perform an API request on the user's behalf. Your application must have that consent before it can execute a Google API request that requires user authorization. The list below quickly summarizes these steps: - Your application identifies the permissions it needs. - Your application redirects the user to Google along with the list of requested permissions. - The user decides whether to grant the permissions to your application. - Your application finds out what the user decided. - If the user granted the requested permissions, your application retrieves tokens needed to make API requests on the user's behalf. Step 1: Set authorization parameters Your first step is to create the authorization request. That request sets parameters that identify your application and define the permissions that the user will be asked to grant to your application. - If you use a Google client library for OAuth 2.0 authentication and authorization, you create and configure an object that defines these parameters. - If you call the Google OAuth 2.0 endpoint directly, you'll generate a URL and set the parameters on that URL. The tabs below define the supported authorization parameters for web server applications. The language-specific examples also show how to use a client library or authorization library to configure an object that sets those parameters. PHP The code snippet below creates a Google\\Client() object, which defines the parameters in the authorization request. That object uses information from your client_secret.json file to identify your application. (See creating authorization credentials for more about that file.) The object also identifies the scopes that your application is requesting permission to access and the URL to your application's auth endpoint, which will handle the response from Google's OAuth 2.0 server. Finally, the code sets the optional access_type and include_granted_scopes parameters. For example, this code requests read-only, offline access to a user's Google Drive: $client = new Google\\Client(); // Required, call the setAuthConfig function to load authorization credentials from // client_secret.json file. $client->setAuthConfig('client_secret.json'); // Required, to set the scope value, call the addScope function $client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY); // Required, call the setRedirectUri function to specify a valid redirect URI for the // provided client_id $client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php'); // Recommended, offline access will give you both an access and refresh token so that // your app can refresh the access token without user interaction. $client->setAccessType('offline'); // Recommended, call the setState function. Using a state value can increase your assurance that // an incoming connection is the result of an authentication request. $client->setState($sample_passthrough_value); // Optional, if your application knows which user is trying to authenticate, it can use this // parameter to provide a hint to the Google Authentication Server. $client->setLoginHint('hint@example.com'); // Optional, call the setPrompt function to set \"consent\" will prompt the user for consent $client->setPrompt('consent'); // Optional, call the setIncludeGrantedScopes function with true to enable incremental // authorization $client->setIncludeGrantedScopes(true); Python The following code snippet uses the google-auth-oauthlib.flow module to construct the authorization request. The code constructs a Flow object, which identifies your application using information from the client_secret.json file that you downloaded after creating authorization credentials . That object also identifies the scopes that your application is requesting permission to access and the URL to your application's auth endpoint, which will handle the response from Google's OAuth 2.0 server. Finally, the code sets the optional access_type and include_granted_scopes parameters. For example, this code requests read-only, offline access to a user's Google Drive: import google.oauth2.credentials import google_auth_oauthlib.flow # Required, call the from_client_secrets_file method to retrieve the client ID from a # client_secret.json file. The client ID (from that file) and access scopes are required. (You can # also use the from_client_config method, which passes the client configuration as it originally # appeared in a client secrets file but doesn't access the file itself.) flow = google_auth_oauthlib . flow . Flow . from_client_secrets_file ( 'client_secret.json' , scopes = [ 'https://www.googleapis.com/auth/drive.metadata.readonly' ]) # Required, indicate where the API server will redirect the user after the user completes # the authorization flow. The redirect URI is required. The value must exactly # match one of the authorized redirect URIs for the OAuth 2.0 client, which you # configured in the API Console. If this value doesn't match an authorized URI, # you will get a 'redirect_uri_mismatch' error. flow . redirect_uri = 'https://www.example.com/oauth2callback' # Generate URL for request to Google's OAuth 2.0 server. # Use kwargs to set optional request parameters. authorization_url , state = flow . authorization_url ( # Recommended, enable offline access so that you can refresh an access token without # re-prompting the user for permission. Recommended for web server apps. access_type = 'offline' , # Optional, enable incremental authorization. Recommended as a best practice. include_granted_scopes = 'true' , # Optional, if your application knows which user is trying to authenticate, it can use this # parameter to provide a hint to the Google Authentication Server. login_hint = 'hint@example.com' , # Optional, set prompt to 'consent' will prompt the user for consent prompt = 'consent' ) Ruby Use the client_secrets.json file that you created to configure a client object in your application. When you configure a client object, you specify the scopes your application needs to access, along with the URL to your application's auth endpoint, which will handle the response from the OAuth 2.0 server. For example, this code requests read-only, offline access to a user's Google Drive: require 'google/apis/drive_v3' require \"googleauth\" require 'googleauth/stores/redis_token_store' client_id = Google :: Auth :: ClientId . from_file ( '/path/to/client_secret.json' ) scope = 'https://www.googleapis.com/auth/drive.metadata.readonly' token_store = Google :: Auth :: Stores :: RedisTokenStore . new ( redis : Redis . new ) authorizer = Google :: Auth :: WebUserAuthorizer . new ( client_id , scope , token_store , '/oauth2callback' ) Your application uses the client object to perform OAuth 2.0 operations, such as generating authorization request URLs and applying access tokens to HTTP requests. Node.js The following code snippet creates a google.auth.OAuth2 object, which defines the parameters in the authorization request. That object uses information from your client_secret.json file to identify your application. To ask for permissions from a user to retrieve an access token, you redirect them to a consent page. To create a consent page URL: const { google } = require ( 'googleapis' ); const crypto = require ( 'crypto' ); const express = require ( 'express' ); const session = require ( 'express-session' ); /** * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI * from the client_secret.json file. To get these credentials for your application, visit * https://console.cloud.google.com/apis/credentials. */ const oauth2Client = new google . auth . OAuth2 ( YOUR_CLIENT_ID , YOUR_CLIENT_SECRET , YOUR_REDIRECT_URL ); // Access scopes for read-only Drive activity. const scopes = [ 'https://www.googleapis.com/auth/drive.metadata.readonly' ]; // Generate a secure random state value. const state = crypto . randomBytes ( 32 ). toString ( 'hex' ); // Store state in the session req . session . state = state ; // Generate a url that asks permissions for the Drive activity scope const authorizationUrl = oauth2Client . generateAuthUrl ({ // 'online' (default) or 'offline' (gets refresh_token) access_type : 'offline' , /** Pass in the scopes array defined above. * Alternatively, if only one scope is needed, you can pass a scope URL as a string */ scope : scopes , // Enable incremental authorization. Recommended as a best practice. include_granted_scopes : true , // Include the state parameter to reduce the risk of CSRF attacks. state : state }); Important Note - The refresh_token is only returned on the first authorization. More details here . HTTP/REST Google's OAuth 2.0 endpoint is at https://accounts.google.com/o/oauth2/v2/auth . This endpoint is accessible only over HTTPS. Plain HTTP connections are refused. The Google authorization server supports the following query string parameters for web server applications: Parameters client_id Required The client ID for your application. You can find this value in the API Console Credentials page . redirect_uri Required Determines where the API server redirects the user after the user completes the authorization flow. The value must exactly match one of the authorized redirect URIs for the OAuth 2.0 client, which you configured in your client's API Console Credentials page . If this value doesn't match an authorized redirect URI for the provided client_id you will get a redirect_uri_mismatch error. Note that the http or https scheme, case, and trailing slash (' / ') must all match. response_type Required Determines whether the Google OAuth 2.0 endpoint returns an authorization code. Set the parameter value to code for web server applications. scope Required A space-delimited list of scopes that identify the resources that your application could access on the user's behalf. These values inform the consent screen that Google displays to the user. Scopes enable your application to only request access to the resources that it needs while also enabling users to control the amount of access that they grant to your application. Thus, there is an inverse relationship between the number of scopes requested and the likelihood of obtaining user consent. We recommend that your application request access to authorization scopes in context whenever possible. By requesting access to user data in context, via incremental authorization , you help users to more easily understand why your application needs the access it is requesting. access_type Recommended Indicates whether your application can refresh access tokens when the user is not present at the browser. Valid parameter values are online , which is the default value, and offline . Set the value to offline if your application needs to refresh access tokens when the user is not present at the browser. This is the method of refreshing access tokens described later in this document. This value instructs the Google authorization server to return a refresh token and an access token the first time that your application exchanges an authorization code for tokens. state Recommended Specifies any string value that your application uses to maintain state between your authorization request and the authorization server's response. The server returns the exact value that you send as a name=value pair in the URL query component ( ? ) of the redirect_uri after the user consents to or denies your application's access request. You can use this parameter for several purposes, such as directing the user to the correct resource in your application, sending nonces, and mitigating cross-site request forgery. Since your redirect_uri can be guessed, using a state value can increase your assurance that an incoming connection is the result of an authentication request. If you generate a random string or encode the hash of a cookie or another value that captures the client's state, you can validate the response to additionally ensure that the request and response originated in the same browser, providing protection against attacks such as cross-site request forgery . See the OpenID Connect documentation for an example of how to create and confirm a state token. Important: The OAuth client must prevent CSRF as called out in the OAuth2 Specification . One way to achieve this is by using the state parameter to maintain state between your authorization request and the authorization server's response. include_granted_scopes Optional Enables applications to use incremental authorization to request access to additional scopes in context. If you set this parameter's value to true and the authorization request is granted, then the new access token will also cover any scopes to which the user previously granted the application access. See the incremental authorization section for examples. enable_granular_consent Optional Defaults to true . If set to false , more granular Google Account permissions will be disabled for OAuth client IDs created before 2019. No effect for newer OAuth client IDs, since more granular permissions is always enabled for them. When Google enables granular permissions for an application, this parameter will no longer have any effect. login_hint Optional If your application knows which user is trying to authenticate, it can use this parameter to provide a hint to the Google Authentication Server. The server uses the hint to simplify the login flow either by prefilling the email field in the sign-in form or by selecting the appropriate multi-login session. Set the parameter value to an email address or sub identifier, which is equivalent to the user's Google ID. prompt Optional A space-delimited, case-sensitive list of prompts to present the user. If you don't specify this parameter, the user will be prompted only the first time your project requests access. See Prompting re-consent for more information. Possible values are: none Do not display any authentication or consent screens. Must not be specified with other values. consent Prompt the user for consent. select_account Prompt the user to select an account. Step 2: Redirect to Google's OAuth 2.0 server Redirect the user to Google's OAuth 2.0 server to initiate the authentication and authorization process. Typically, this occurs when your application first needs to access the user's data. In the case of incremental authorization , this step also occurs when your application first needs to access additional resources that it does not yet have permission to access. PHP - Generate a URL to request access from Google's OAuth 2.0 server: $auth_url = $client->createAuthUrl(); - Redirect the user to $auth_url : header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL)); Python This example shows how to redirect the user to the authorization URL using the Flask web application framework: return flask . redirect ( authorization_url ) Ruby - Generate a URL to request access from Google's OAuth 2.0 server: auth_uri = authorizer . get_authorization_url ( login_hint : user_id , request : request ) - Redirect the user to auth_uri . Node.js - Use the generated URL authorizationUrl from Step 1 generateAuthUrl method to request access from Google's OAuth 2.0 server. - Redirect the user to authorizationUrl . res . redirect ( authorizationUrl ); HTTP/REST Sample redirect to Google's authorization server An example URL is shown below, with line breaks and spaces for readability. https://accounts.google.com/o/oauth2/v2/auth? scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly& access_type=offline& include_granted_scopes=true& response_type=code& state= state_parameter_passthrough_value & redirect_uri= https%3A//oauth2.example.com/code & client_id= client_id After you create the request URL, redirect the user to it. Google's OAuth 2.0 server authenticates the user and obtains consent from the user for your application to access the requested scopes. The response is sent back to your application using the redirect URL you specified. Step 3: Google prompts user for consent In this step, the user decides whether to grant your application the requested access. At this stage, Google displays a consent window that shows the name of your application and the Google API services that it is requesting permission to access with the user's authorization credentials and a summary of the scopes of access to be granted. The user can then consent to grant access to one or more scopes requested by your application or refuse the request. Your application doesn't need to do anything at this stage as it waits for the response from Google's OAuth 2.0 server indicating whether any access was granted. That response is explained in the following step. Errors Requests to Google's OAuth 2.0 authorization endpoint may display user-facing error messages instead of the expected authentication and authorization flows. Common error codes and suggested resolutions are listed below. admin_policy_enforced The Google Account is unable to authorize one or more scopes requested due to the policies of their Google Workspace administrator. See the Google Workspace Admin help article Control which third-party & internal apps access Google Workspace data for more information about how an administrator may restrict access to all scopes or sensitive and restricted scopes until access is explicitly granted to your OAuth client ID. disallowed_useragent The authorization endpoint is displayed inside an embedded user-agent disallowed by Google's OAuth 2.0 Policies . Android Android developers may encounter this error message when opening authorization requests in android.webkit.WebView . Developers should instead use Android libraries such as Google Sign-In for Android or OpenID Foundation's AppAuth for Android . Web developers may encounter this error when an Android app opens a general web link in an embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from your site. Developers should allow general links to open in the default link handler of the operating system, which includes both Android App Links handlers or the default browser app. The Android Custom Tabs library is also a supported option. iOS iOS and macOS developers may encounter this error when opening authorization requests in WKWebView . Developers should instead use iOS libraries such as Google Sign-In for iOS or OpenID Foundation's AppAuth for iOS . Web developers may encounter this error when an iOS or macOS app opens a general web link in an embedded user-agent and a user navigates to Google's OAuth 2.0 authorization endpoint from your site. Developers should allow general links to open in the default link handler of the operating system, which includes both Universal Links handlers or the default browser app. The SFSafariViewController library is also a supported option. org_internal The OAuth client ID in the request is part of a project limiting access to Google Accounts in a specific Google Cloud Organization . For more information about this configuration option see the User type section in the Setting up your OAuth consent screen help article. invalid_client The OAuth client secret is incorrect. Review the OAuth client configuration , including the client ID and secret used for this request. invalid_grant When refreshing an access token or using incremental authorization , the token may have expired or has been invalidated. Authenticate the user again and ask for user consent to obtain new tokens. If you are continuing to see this error, ensure that your application has been configured correctly and that you are using the correct tokens and parameters in your request. Otherwise, the user account may have been deleted or disabled. redirect_uri_mismatch The redirect_uri passed in the authorization request does not match an authorized redirect URI for the OAuth client ID. Review authorized redirect URIs in the Google API Console Credentials page . The redirect_uri parameter may refer to the OAuth out-of-band (OOB) flow that has been deprecated and is no longer supported. Refer to the migration guide to update your integration. invalid_request There was something wrong with the request you made. This could be due to a number of reasons: - The request was not properly formatted - The request was missing required parameters - The request uses an authorization method that Google doesn't support. Verify your OAuth integration uses a recommended integration method Step 4: Handle the OAuth 2.0 server response Important: Before handling the OAuth 2.0 response on the server, you should confirm that the state received from Google matches the state sent in the authorization request. This verification helps to ensure that the user, not a malicious script, is making the request and reduces the risk of CSRF attacks . The OAuth 2.0 server responds to your application's access request by using the URL specified in the request. If the user approves the access request, then the response contains an authorization code. If the user does not approve the request, the response contains an error message. The authorization code or error message that is returned to the web server appears on the query string, as shown below: An error response: https://oauth2.example.com/auth?error=access_denied An authorization code response: https://oauth2.example.com/auth?code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7 Important: If your response endpoint renders an HTML page, any resources on that page will be able to see the authorization code in the URL. Scripts can read the URL directly, and the URL in the Referer HTTP header may be sent to any or all resources on the page. Carefully consider whether you want to send authorization credentials to all resources on that page (especially third-party scripts such as social plugins and analytics). To avoid this issue, we recommend that the server first handle the request, then redirect to another URL that doesn't include the response parameters. Sample OAuth 2.0 server response You can test this flow by clicking on the following sample URL, which requests read-only access to view metadata for files in your Google Drive: https://accounts.google.com/o/oauth2/v2/auth? scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly& access_type=offline& include_granted_scopes=true& response_type=code& state= state_parameter_passthrough_value & redirect_uri= https%3A//oauth2.example.com/code & client_id= client_id After completing the OAuth 2.0 flow, you should be redirected to http://localhost/oauth2callback , which will likely yield a 404 NOT FOUND error unless your local machine serves a file at that address. The next step provides more detail about the information returned in the URI when the user is redirected back to your application. Step 5: Exchange authorization code for refresh and access tokens After the web server receives the authorization code, it can exchange the authorization code for an access token. PHP To exchange an authorization code for an access token, use the authenticate method: $client->authenticate($_GET['code']); You can retrieve the access token with the getAccessToken method: $access_token = $client->getAccessToken(); Python On your callback page, use the google-auth library to verify the authorization server response. Then, use the flow.fetch_token method to exchange the authorization code in that response for an access token: state = flask . session [ 'state' ] flow = google_auth_oauthlib . flow . Flow . from_client_secrets_file ( 'client_secret.json' , scopes = [ 'https://www.googleapis.com/auth/drive.metadata.readonly' ], state = state ) flow . redirect_uri = flask . url_for ( 'oauth2callback' , _external = True ) authorization_response = flask . request . url flow . fetch_token ( authorization_response = authorization_response ) # Store the credentials in the session. # ACTION ITEM for developers: # Store user's access and refresh tokens in your data store if # incorporating this code into your real app. credentials = flow . credentials flask . session [ 'credentials' ] = { 'token' : credentials . token , 'refresh_token' : credentials . refresh_token , 'token_uri' : credentials . token_uri , 'client_id' : credentials . client_id , 'client_secret' : credentials . client_secret , 'scopes' : credentials . scopes } Ruby On your callback page, use the googleauth library to verify the authorization server response. Use the authorizer.handle_auth_callback_deferred method to save the authorization code and redirect back to the URL that originally requested authorization. This defers the exchange of the code by temporarily stashing the results in the user's session. target_url = Google :: Auth :: WebUserAuthorizer . handle_auth_callback_deferred ( request ) redirect target_url Node.js To exchange an authorization code for an access token, use the getToken method: const url = require ( 'url' ); // Receive the callback from Google's OAuth 2.0 server. app . get ( '/oauth2callback' , async ( req , res ) => { let q = url . parse ( req . url , true ). query ; if ( q . error ) { // An error response e.g. error=access_denied console . log ( 'Error:' + q . error ); } else if ( q . state !== req . session . state ) { //check state value console . log ( 'State mismatch. Possible CSRF attack' ); res . end ( 'State mismatch. Possible CSRF attack' ); } else { // Get access and refresh tokens (if access_type is offline) let { tokens } = await oauth2Client . getToken ( q . code ); oauth2Client . setCredentials ( tokens ); }); HTTP/REST To exchange an authorization code for an access token, call the https://oauth2.googleapis.com/token endpoint and set the following parameters: Fields client_id The client ID obtained from the API Console Credentials page . client_secret The client secret obtained from the API Console Credentials page . code The authorization code returned from the initial request. grant_type As defined in the OAuth 2.0 specification , this field's value must be set to authorization_code . redirect_uri One of the redirect URIs listed for your project in the API Console Credentials page for the given client_id . The following snippet shows a sample request: POST /token HTTP/1.1 Host: oauth2.googleapis.com Content-Type: application/x-www-form-urlencoded code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7& client_id= your_client_id & client_secret= your_client_secret & redirect_uri=https%3A//oauth2.example.com/code& grant_type=authorization_code Google responds to this request by returning a JSON object that contains a short-lived access token and a refresh token. Note that the refresh token is only returned if your application set the access_type parameter to offline in the initial request to Google's authorization server . The response contains the following fields: Fields access_token The token that your application sends to authorize a Google API request. expires_in The remaining lifetime of the access token in seconds. refresh_token A token that you can use to obtain a new access token. Refresh tokens are valid until the user revokes access. Again, this field is only present in this response if you set the access_type parameter to offline in the initial request to Google's authorization server. scope The scopes of access granted by the access_token expressed as a list of space-delimited, case-sensitive strings. token_type The type of token returned. At this time, this field's value is always set to Bearer . Important: Your application should store both tokens in a secure, long-lived location that is accessible between different invocations of your application. The refresh token enables your application to obtain a new access token if the one that you have expires. As such, if your application loses the refresh token, the user will need to repeat the OAuth 2.0 consent flow so that your application can obtain a new refresh token. The following snippet shows a sample response: { \"access_token\" : \"1/fFAGRNJru1FTz70BzhT3Zg\" , \"expires_in\" : 3920 , \"token_type\" : \"Bearer\" , \"scope\" : \"https://www.googleapis.com/auth/drive.metadata.readonly\" , \"refresh_token\" : \"1//xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI\" } Note: Your application should ignore any unrecognized fields included in the response. Errors When exchanging the authorization code for an access token you may encounter the following error instead of the expected response. Common error codes and suggested resolutions are listed below. invalid_grant The supplied authorization code is invalid or in the wrong format. Request a new code by restarting the OAuth process to prompt the user for consent again. Calling Google APIs PHP Use the access token to call Google APIs by completing the following steps: - If you need to apply an access token to a new Google\\Client object — for example, if you stored the access token in a user session — use the setAccessToken method: $client->setAccessToken($access_token); - Build a service object for the API that you want to call. You build a service object by providing an authorized Google\\Client object to the constructor for the API you want to call. For example, to call the Drive API: $drive = new Google\\Service\\Drive($client); - Make requests to the API service using the interface provided by the service object . For example, to list the files in the authenticated user's Google Drive: $files = $drive->files->listFiles(array())->getItems(); Python After obtaining an access token, your application can use that token to authorize API requests on behalf of a given user account or service account. Use the user-specific authorization credentials to build a service object for the API that you want to call, and then use that object to make authorized API requests. - Build a service object for the API that you want to call. You build a service object by calling the googleapiclient.discovery library's build method with the name and version of the API and the user credentials: For example, to call version 3 of the Drive API: from googleapiclient.discovery import build drive = build ( 'drive' , 'v2' , credentials = credentials ) - Make requests to the API service using the interface provided by the service object . For example, to list the files in the authenticated user's Google Drive: files = drive . files () . list () . execute () Ruby After obtaining an access token, your application can use that token to make API requests on behalf of a given user account or service account. Use the user-specific authorization credentials to build a service object for the API that you want to call, and then use that object to make authorized API requests. - Build a service object for the API that you want to call. For example, to call version 3 of the Drive API: drive = Google :: Apis :: DriveV3 :: DriveService . new - Set the credentials on the service: drive . authorization = credentials - Make requests to the API service using the interface provided by the service object . For example, to list the files in the authenticated user's Google Drive: files = drive . list_files Alternately, authorization can be provided on a per-method basis by supplying the options parameter to a method: files = drive . list_files ( options : { authorization : credentials }) Node.js After obtaining an access token and setting it to the OAuth2 object, use the object to call Google APIs. Your application can use that token to authorize API requests on behalf of a given user account or service account. Build a service object for the API that you want to call. const { google } = require ( 'googleapis' ); // Example of using Google Drive API to list filenames in user's Drive. const drive = google . drive ( 'v3' ); drive . files . list ({ auth : oauth2Client , pageSize : 10 , fields : 'nextPageToken, files(id, name)' , }, ( err1 , res1 ) => { if ( err1 ) return console . log ( 'The API returned an error: ' + err1 ); const files = res1 . data . files ; if ( files . length ) { console . log ( 'Files:' ); files . map (( file ) => { console . log ( ` ${ file . name } ( ${ file . id } )` ); }); } else { console . log ( 'No files found.' ); } }); HTTP/REST After your application obtains an access token, you can use the token to make calls to a Google API on behalf of a given user account if the scope(s) of access required by the API have been granted. To do this, include the access token in a request to the API by including either an access_token query parameter or an Authorization HTTP header Bearer value. When possible, the HTTP header is preferable, because query strings tend to be visible in server logs. In most cases you can use a client library to set up your calls to Google APIs (for example, when calling the Drive Files API ). You can try out all the Google APIs and view their scopes at the OAuth 2.0 Playground . HTTP GET examples A call to the drive.files endpoint (the Drive Files API) using the Authorization: Bearer HTTP header might look like the following. Note that you need to specify your own access token: GET /drive/v2/files HTTP/1.1 Host: www.googleapis.com Authorization: Bearer access_token Here is a call to the same API for the authenticated user using the access_token query string parameter: GET https://www.googleapis.com/drive/v2/files?access_token= access_token curl examples You can test these commands with the curl command-line application. Here's an example that uses the HTTP header option (preferred): curl -H \"Authorization: Bearer access_token \" https://www.googleapis.com/drive/v2/files Or, alternatively, the query string parameter option: curl https://www.googleapis.com/drive/v2/files?access_token= access_token Complete example The following example prints a JSON-formatted list of files in a user's Google Drive after the user authenticates and gives consent for the application to access the user's Drive metadata. PHP To run this example: - In the API Console, add the URL of the local machine to the list of redirect URLs. For example, add http://localhost:8080 . - Create a new directory and change to it. For example: mkdir ~/php-oauth2-example cd ~/php-oauth2-example - Install the Google API Client Library for PHP using Composer : composer require google/apiclient:^2.10 - Create the files index.php and oauth2callback.php with the content below. - Run the example with a web server configured to serve PHP. If you use PHP 5.6 or newer, you can use PHP's built-in test web server: php -S localhost:8080 ~/php-oauth2-example index.php < ?php require_once __DIR__.'/vendor/autoload.php'; session_start(); $client = new Google\\Client(); $client->setAuthConfig('client_secrets.json'); $client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY); if (isset($_SESSION['access_token']) && $_SESSION['access_token']) { $client->setAccessToken($_SESSION['access_token']); $drive = new Google\\Service\\Drive($client); $files = $drive->files->listFiles(array())->getItems(); echo json_encode($files); } else { $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php'; header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL)); } oauth2callback.php < ?php require_once __DIR__.'/vendor/autoload.php'; session_start(); $client = new Google\\Client(); $client->setAuthConfigFile('client_secrets.json'); $client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php'); $client->addScope(Google\\Service\\Drive::DRIVE_METADATA_READONLY); if (! isset($_GET['code'])) { // Generate and set state value $state = bin2hex(random_bytes(16)); $client->setState($state); $_SESSION['state'] = $state; $auth_url = $client->createAuthUrl(); header('Location: ' . filter_var($auth_url, FILTER_SANITIZE_URL)); } else { // Check the state value if (!isset($_GET['state']) || $_GET['state'] !== $_SESSION['state']) { die('State mismatch. Possible CSRF attack.'); } $client->authenticate($_GET['code']); $_SESSION['access_token'] = $client->getAccessToken(); $redirect_uri = 'http://' . $_SERVER['HTTP_HOST'] . '/'; header('Location: ' . filter_var($redirect_uri, FILTER_SANITIZE_URL)); } Python This example uses the Flask framework. It runs a web application at http://localhost:8080 that lets you test the OAuth 2.0 flow. If you go to that URL, you should see four links: - Test an API request: This link points to a page that tries to execute a sample API request. If necessary, it starts the authorization flow. If successful, the page displays the API response. - Test the auth flow directly: This link points to a page that tries to send the user through the authorization flow . The app requests permission to submit authorized API requests on the user's behalf. - Revoke current credentials: This link points to a page that revokes permissions that the user has already granted to the application. - Clear Flask session credentials: This link clears authorization credentials that are stored in the Flask session. This lets you see what would happen if a user who had already granted permission to your app tried to execute an API request in a new session. It also lets you see the API response your app would get if a user had revoked permissions granted to your app, and your app still tried to authorize a request with a revoked access token. Note: To run this code locally, you must have followed the directions in the prerequisites section, including setting http://localhost:8080 as a valid redirect URI for your credentials and downloading the client_secret.json file for those credentials to your working directory. # -*- coding: utf-8 -*- import os import flask import requests import google.oauth2.credentials import google_auth_oauthlib.flow import googleapiclient.discovery # This variable specifies the name of a file that contains the OAuth 2.0 # information for this application, including its client_id and client_secret. CLIENT_SECRETS_FILE = \"client_secret.json\" # This OAuth 2.0 access scope allows for full read/write access to the # authenticated user's account and requires requests to use an SSL connection. SCOPES = [ 'https://www.googleapis.com/auth/drive.metadata.readonly' ] API_SERVICE_NAME = 'drive' API_VERSION = 'v2' app = flask . Flask ( __name__ ) # Note: A secret key is included in the sample so that it works. # If you use this code in your application, replace this with a truly secret # key. See https://flask.palletsprojects.com/quickstart/#sessions. app . secret_key = 'REPLACE ME - this value is here as a placeholder.' @app . route ( '/' ) def index (): return print_index_table () @app . route ( '/test' ) def test_api_request (): if 'credentials' not in flask . session : return flask . redirect ( 'authorize' ) # Load credentials from the session. credentials = google . oauth2 . credentials . Credentials ( ** flask . session [ 'credentials' ]) drive = googleapiclient . discovery . build ( API_SERVICE_NAME , API_VERSION , credentials = credentials ) files = drive . files () . list () . execute () # Save credentials back to session in case access token was refreshed. # ACTION ITEM: In a production app, you likely want to save these # credentials in a persistent database instead. flask . session [ 'credentials' ] = credentials_to_dict ( credentials ) return flask . jsonify ( ** files ) @app . route ( '/authorize' ) def authorize (): # Create flow instance to manage the OAuth 2.0 Authorization Grant Flow steps. flow = google_auth_oauthlib . flow . Flow . from_client_secrets_file ( CLIENT_SECRETS_FILE , scopes = SCOPES ) # The URI created here must exactly match one of the authorized redirect URIs # for the OAuth 2.0 client, which you configured in the API Console. If this # value doesn't match an authorized URI, you will get a 'redirect_uri_mismatch' # error. flow . redirect_uri = flask . url_for ( 'oauth2callback' , _external = True ) authorization_url , state = flow . authorization_url ( # Enable offline access so that you can refresh an access token without # re-prompting the user for permission. Recommended for web server apps. access_type = 'offline' , # Enable incremental authorization. Recommended as a best practice. include_granted_scopes = 'true' ) # Store the state so the callback can verify the auth server response. flask . session [ 'state' ] = state return flask . redirect ( authorization_url ) @app . route ( '/oauth2callback' ) def oauth2callback (): # Specify the state when creating the flow in the callback so that it can # verified in the authorization server response. state = flask . session [ 'state' ] flow = google_auth_oauthlib . flow . Flow . from_client_secrets_file ( CLIENT_SECRETS_FILE , scopes = SCOPES , state = state ) flow . redirect_uri = flask . url_for ( 'oauth2callback' , _external = True ) # Use the authorization server's response to fetch the OAuth 2.0 tokens. authorization_response = flask . request . url flow . fetch_token ( authorization_response = authorization_response ) # Store credentials in the session. # ACTION ITEM: In a production app, you likely want to save these # credentials in a persistent database instead. credentials = flow . credentials flask . session [ 'credentials' ] = credentials_to_dict ( credentials ) return flask . redirect ( flask . url_for ( 'test_api_request' )) @app . route ( '/revoke' ) def revoke (): if 'credentials' not in flask . session : return ( 'You need to <a href=\"/authorize\">authorize</a> before ' + 'testing the code to revoke credentials.' ) credentials = google . oauth2 . credentials . Credentials ( ** flask . session [ 'credentials' ]) revoke = requests . post ( 'https://oauth2.googleapis.com/revoke' , params = { 'token' : credentials . token }, headers = { 'content-type' : 'application/x-www-form-urlencoded' }) status_code = getattr ( revoke , 'status_code' ) if status_code == 200 : return ( 'Credentials successfully revoked.' + print_index_table ()) else : return ( 'An error occurred.' + print_index_table ()) @app . route ( '/clear' ) def clear_credentials (): if 'credentials' in flask . session : del flask . session [ 'credentials' ] return ( 'Credentials have been cleared.<br><br>' + print_index_table ()) def credentials_to_dict ( credentials ): return { 'token' : credentials . token , 'refresh_token' : credentials . refresh_token , 'token_uri' : credentials . token_uri , 'client_id' : credentials . client_id , 'client_secret' : credentials . client_secret , 'scopes' : credentials . scopes } def print_index_table (): return ( '<table>' + '<tr><td><a href=\"/test\">Test an API request</a></td>' + '<td>Submit an API request and see a formatted JSON response. ' + ' Go through the authorization flow if there are no stored ' + ' credentials for the user.</td></tr>' + '<tr><td><a href=\"/authorize\">Test the auth flow directly</a></td>' + '<td>Go directly to the authorization flow. If there are stored ' + ' credentials, you still might not be prompted to reauthorize ' + ' the application.</td></tr>' + '<tr><td><a href=\"/revoke\">Revoke current credentials</a></td>' + '<td>Revoke the access token associated with the current user ' + ' session. After revoking credentials, if you go to the test ' + ' page, you should see an <code>invalid_grant</code> error.' + '</td></tr>' + '<tr><td><a href=\"/clear\">Clear Flask session credentials</a></td>' + '<td>Clear the access token currently stored in the user session. ' + ' After clearing the token, if you <a href=\"/test\">test the ' + ' API request</a> again, you should go back to the auth flow.' + '</td></tr></table>' ) if __name__ == '__main__' : # When running locally, disable OAuthlib's HTTPs verification. # ACTION ITEM for developers: # When running in production *do not* leave this option enabled. os . environ [ 'OAUTHLIB_INSECURE_TRANSPORT' ] = '1' # Specify a hostname and port that are set as a valid redirect URI # for your API project in the Google API Console. app . run ( 'localhost' , 8080 , debug = True ) Ruby This example uses the Sinatra framework. require 'google/apis/drive_v3' require 'sinatra' require 'googleauth' require 'googleauth/stores/redis_token_store' configure do enable :sessions set :client_id , Google :: Auth :: ClientId . from_file ( '/path/to/client_secret.json' ) set :scope , Google :: Apis :: DriveV3 :: AUTH_DRIVE_METADATA_READONLY set :token_store , Google :: Auth :: Stores :: RedisTokenStore . new ( redis : Redis . new ) set :authorizer , Google :: Auth :: WebUserAuthorizer . new ( settings . client_id , settings . scope , settings . token_store , '/oauth2callback' ) end get '/' do user_id = settings . client_id . id credentials = settings . authorizer . get_credentials ( user_id , request ) if credentials . nil? redirect settings . authorizer . get_authorization_url ( login_hint : user_id , request : request ) end drive = Google :: Apis :: DriveV3 :: DriveService . new files = drive . list_files ( options : { authorization : credentials }) \"<pre> #{ JSON . pretty_generate ( files . to_h ) } < /pre>\" end get '/oauth2callback' do target_url = Google :: Auth :: WebUserAuthorizer . handle_auth_callback_deferred ( request ) redirect target_url end Node.js To run this example: - In the API Console, add the URL of the local machine to the list of redirect URLs. For example, add http://localhost . - Make sure you have maintenance LTS, active LTS, or current release of Node.js installed. - Create a new directory and change to it. For example: mkdir ~/nodejs-oauth2-example cd ~/nodejs-oauth2-example - Install the Google API Client Library for Node.js using npm : npm install googleapis - Create the files main.js with the content below. - Run the example: node .\\main.js main.js const http = require ( 'http' ); const https = require ( 'https' ); const url = require ( 'url' ); const { google } = require ( 'googleapis' ); const crypto = require ( 'crypto' ); const express = require ( 'express' ); const session = require ( 'express-session' ); /** * To use OAuth2 authentication, we need access to a CLIENT_ID, CLIENT_SECRET, AND REDIRECT_URI. * To get these credentials for your application, visit * https://console.cloud.google.com/apis/credentials. */ const oauth2Client = new google . auth . OAuth2 ( YOUR_CLIENT_ID , YOUR_CLIENT_SECRET , YOUR_REDIRECT_URL ); // Access scopes for read-only Drive activity. const scopes = [ 'https://www.googleapis.com/auth/drive.metadata.readonly' ]; /* Global variable that stores user credential in this code example. * ACTION ITEM for developers: * Store user's refresh token in your data store if * incorporating this code into your real app. * For more information on handling refresh tokens, * see https://github.com/googleapis/google-api-nodejs-client#handling-refresh-tokens */ let userCredential = null ; async function main () { const app = express (); app . use ( session ({ secret : 'your_secure_secret_key' , // Replace with a strong secret resave : false , saveUninitialized : false , })); // Example on redirecting user to Google's OAuth 2.0 server. app . get ( '/' , async ( req , res ) => { // Generate a secure random state value. const state = crypto . randomBytes ( 32 ). toString ( 'hex' ); // Store state in the session req . session . state = state ; // Generate a url that asks permissions for the Drive activity scope const authorizationUrl = oauth2Client . generateAuthUrl ({ // 'online' (default) or 'offline' (gets refresh_token) access_type : 'offline' , /** Pass in the scopes array defined above. * Alternatively, if only one scope is needed, you can pass a scope URL as a string */ scope : scopes , // Enable incremental authorization. Recommended as a best practice. include_granted_scopes : true , // Include the state parameter to reduce the risk of CSRF attacks. state : state }); res . redirect ( authorizationUrl ); }); // Receive the callback from Google's OAuth 2.0 server. app . get ( '/oauth2callback' , async ( req , res ) => { // Handle the OAuth 2.0 server response let q = url . parse ( req . url , true ). query ; if ( q . error ) { // An error response e.g. error=access_denied console . log ( 'Error:' + q . error ); } else if ( q . state !== req . session . state ) { //check state value console . log ( 'State mismatch. Possible CSRF attack' ); res . end ( 'State mismatch. Possible CSRF attack' ); } else { // Get access and refresh tokens (if access_type is offline) let { tokens } = await oauth2Client . getToken ( q . code ); oauth2Client . setCredentials ( tokens ); /** Save credential to the global variable in case access token was refreshed. * ACTION ITEM: In a production app, you likely want to save the refresh token * in a secure persistent database instead. */ userCredential = tokens ; // Example of using Google Drive API to list filenames in user's Drive. const drive = google . drive ( 'v3' ); drive . files . list ({ auth : oauth2Client , pageSize : 10 , fields : 'nextPageToken, files(id, name)' , }, ( err1 , res1 ) => { if ( err1 ) return console . log ( 'The API returned an error: ' + err1 ); const files = res1 . data . files ; if ( files . length ) { console . log ( 'Files:' ); files . map (( file ) => { console . log ( ` ${ file . name } ( ${ file . id } )` ); }); } else { console . log ( 'No files found.' ); } }); } }); // Example on revoking a token app . get ( '/revoke' , async ( req , res ) => { // Build the string for the POST request let postData = \"token=\" + userCredential . access_token ; // Options for POST request to Google's OAuth 2.0 server to revoke a token let postOptions = { host : 'oauth2.googleapis.com' , port : '443' , path : '/revoke' , method : 'POST' , headers : { 'Content-Type' : 'application/x-www-form-urlencoded' , 'Content-Length' : Buffer . byteLength ( postData ) } }; // Set up the request const postReq = https . request ( postOptions , function ( res ) { res . setEncoding ( 'utf8' ); res . on ( 'data' , d => { console . log ( 'Response: ' + d ); }); }); postReq . on ( 'error' , error => { console . log ( error ) }); // Post the request with data postReq . write ( postData ); postReq . end (); }); const server = http . createServer ( app ); server . listen ( 80 ); } main (). catch ( console . error ); HTTP/REST This Python example uses the Flask framework and the Requests library to demonstrate the OAuth 2.0 web flow. We recommend using the Google API Client Library for Python for this flow. (The example in the Python tab does use the client library.) import json import flask import requests app = flask . Flask ( __name__ ) CLIENT_ID = '123456789.apps.googleusercontent.com' CLIENT_SECRET = 'abc123' # Read from a file or environmental variable in a real app SCOPE = 'https://www.googleapis.com/auth/drive.metadata.readonly' REDIRECT_URI = 'http://example.com/oauth2callback' @app . route ( '/' ) def index (): if 'credentials' not in flask . session : return flask . redirect ( flask . url_for ( 'oauth2callback' )) credentials = json . loads ( flask . session [ 'credentials' ]) if credentials [ 'expires_in' ] < = 0 : return flask . redirect ( flask . url_for ( 'oauth2callback' )) else : headers = { 'Authorization' : 'Bearer {} ' . format ( credentials [ 'access_token' ])} req_uri = 'https://www.googleapis.com/drive/v2/files' r = requests . get ( req_uri , headers = headers ) return r . text @app . route ( '/oauth2callback' ) def oauth2callback (): if 'code' not in flask . request . args : state = str ( uuid . uuid4 ()) flask . session [ 'state' ] = state auth_uri = ( 'https://accounts.google.com/o/oauth2/v2/auth?response_type=code' '&client_id= {} &redirect_uri= {} &scope= {} &state= {} ' ) . format ( CLIENT_ID , REDIRECT_URI , SCOPE , state ) return flask . redirect ( auth_uri ) else : if 'state' not in flask . request . args or flask . request . args [ 'state' ] != flask . session [ 'state' ]: return 'State mismatch. Possible CSRF attack.' , 400 auth_code = flask . request . args . get ( 'code' ) data = { 'code' : auth_code , 'client_id' : CLIENT_ID , 'client_secret' : CLIENT_SECRET , 'redirect_uri' : REDIRECT_URI , 'grant_type' : 'authorization_code' } r = requests . post ( 'https://oauth2.googleapis.com/token' , data = data ) flask . session [ 'credentials' ] = r . text return flask . redirect ( flask . url_for ( 'index' )) if __name__ == '__main__' : import uuid app . secret_key = str ( uuid . uuid4 ()) app . debug = False app . run () Redirect URI validation rules Google applies the following validation rules to redirect URIs in order to help developers keep their applications secure. Your redirect URIs must adhere to these rules. See RFC 3986 section 3 for the definition of domain, host, path, query, scheme and userinfo, mentioned below. Validation rules Scheme Redirect URIs must use the HTTPS scheme, not plain HTTP. Localhost URIs (including localhost IP address URIs) are exempt from this rule. Host Hosts cannot be raw IP addresses. Localhost IP addresses are exempted from this rule. Domain - Host TLDs ( Top Level Domains ) must belong to the public suffix list . - Host domains cannot be “googleusercontent.com” . - Redirect URIs cannot contain URL shortener domains (e.g. goo.gl ) unless the app owns the domain. Furthermore, if an app that owns a shortener domain chooses to redirect to that domain, that redirect URI must either contain “/google-callback/” in its path or end with “/google-callback” . Userinfo Redirect URIs cannot contain the userinfo subcomponent. Path Redirect URIs cannot contain a path traversal (also called directory backtracking), which is represented by an “/..” or “\\..” or their URL encoding. Query Redirect URIs cannot contain open redirects . Fragment Redirect URIs cannot contain the fragment component. Characters Redirect URIs cannot contain certain characters including: - Wildcard characters ( '*' ) - Non-printable ASCII characters - Invalid percent encodings (any percent encoding that does not follow URL-encoding form of a percent sign followed by two hexadecimal digits) - Null characters (an encoded NULL character, e.g., %00 , %C0%80 ) Incremental authorization In the OAuth 2.0 protocol, your app requests authorization to access resources, which are identified by scopes. It is considered a best user-experience practice to request authorization for resources at the time you need them. To enable that practice, Google's authorization server supports incremental authorization. This feature lets you request scopes as they are needed and, if the user grants permission for the new scope, returns an authorization code that may be exchanged for a token containing all scopes the user has granted the project. For example, an app that lets people sample music tracks and create mixes might need very few resources at sign-in time, perhaps nothing more than the name of the person signing in. However, saving a completed mix would require access to their Google Drive. Most people would find it natural if they only were asked for access to their Google Drive at the time the app actually needed it. In this case, at sign-in time the app might request the openid and profile scopes to perform basic sign-in, and then later request the https://www.googleapis.com/auth/drive.file scope at the time of the first request to save a mix. To implement incremental authorization, you complete the normal flow for requesting an access token but make sure that the authorization request includes previously granted scopes. This approach allows your app to avoid having to manage multiple access tokens. The following rules apply to an access token obtained from an incremental authorization: - The token can be used to access resources corresponding to any of the scopes rolled into the new, combined authorization. - When you use the refresh token for the combined authorization to obtain an access token, the access token represents the combined authorization and can be used for any of the scope values included in the response. - The combined authorization includes all scopes that the user granted to the API project even if the grants were requested from different clients. For example, if a user granted access to one scope using an application's desktop client and then granted another scope to the same application via a mobile client, the combined authorization would include both scopes. - If you revoke a token that represents a combined authorization, access to all of that authorization's scopes on behalf of the associated user are revoked simultaneously. Caution: choosing to include granted scopes will automatically add scopes previously granted by the user to your authorization request. A warning or error page may be displayed if your app is not currently approved to request all scopes that may be returned in the response. See Unverified apps for more information. The language-specific code samples in Step 1: Set authorization parameters and the sample HTTP/REST redirect URL in Step 2: Redirect to Google's OAuth 2.0 server all use incremental authorization. The code samples below also show the code that you need to add to use incremental authorization. PHP $client->setIncludeGrantedScopes(true); Python In Python, set the include_granted_scopes keyword argument to true to ensure that an authorization request includes previously granted scopes. It is very possible that include_granted_scopes will not be the only keyword argument that you set, as shown in the example below. authorization_url , state = flow . authorization_url ( # Enable offline access so that you can refresh an access token without # re-prompting the user for permission. Recommended for web server apps. access_type = 'offline' , # Enable incremental authorization. Recommended as a best practice. include_granted_scopes = 'true' ) Ruby auth_client . update! ( :additional_parameters => { \"include_granted_scopes\" => \"true\" } ) Node.js const authorizationUrl = oauth2Client . generateAuthUrl ({ // 'online' (default) or 'offline' (gets refresh_token) access_type : 'offline' , /** Pass in the scopes array defined above. * Alternatively, if only one scope is needed, you can pass a scope URL as a string */ scope : scopes , // Enable incremental authorization. Recommended as a best practice. include_granted_scopes : true }); HTTP/REST GET https://accounts.google.com/o/oauth2/v2/auth? client_id=your_client_id& response_type=code& state=state_parameter_passthrough_value& scope=https%3A//www.googleapis.com/auth/drive.file& redirect_uri=https%3A//oauth2.example.com/code& prompt=consent& include_granted_scopes=true Refreshing an access token (offline access) Access tokens periodically expire and become invalid credentials for a related API request. You can refresh an access token without prompting the user for permission (including when the user is not present) if you requested offline access to the scopes associated with the token. - If you use a Google API Client Library, the client object refreshes the access token as needed as long as you configure that object for offline access. - If you are not using a client library, you need to set the access_type HTTP query parameter to offline when redirecting the user to Google's OAuth 2.0 server . In that case, Google's authorization server returns a refresh token when you exchange an authorization code for an access token. Then, if the access token expires (or at any other time), you can use a refresh token to obtain a new access token. Requesting offline access is a requirement for any application that needs to access a Google API when the user is not present. For example, an app that performs backup services or executes actions at predetermined times needs to be able to refresh its access token when the user is not present. The default style of access is called online . Server-side web applications, installed applications, and devices all obtain refresh tokens during the authorization process. Refresh tokens are not typically used in client-side (JavaScript) web applications. PHP If your application needs offline access to a Google API, set the API client's access type to offline : $client->setAccessType(\"offline\"); After a user grants offline access to the requested scopes, you can continue to use the API client to access Google APIs on the user's behalf when the user is offline. The client object will refresh the access token as needed. Python In Python, set the access_type keyword argument to offline to ensure that you will be able to refresh the access token without having to re-prompt the user for permission. It is very possible that access_type will not be the only keyword argument that you set, as shown in the example below. authorization_url , state = flow . authorization_url ( # Enable offline access so that you can refresh an access token without # re-prompting the user for permission. Recommended for web server apps. access_type = 'offline' , # Enable incremental authorization. Recommended as a best practice. include_granted_scopes = 'true' ) After a user grants offline access to the requested scopes, you can continue to use the API client to access Google APIs on the user's behalf when the user is offline. The client object will refresh the access token as needed. Ruby If your application needs offline access to a Google API, set the API client's access type to offline : auth_client . update! ( :additional_parameters => { \"access_type\" => \"offline\" } ) After a user grants offline access to the requested scopes, you can continue to use the API client to access Google APIs on the user's behalf when the user is offline. The client object will refresh the access token as needed. Node.js If your application needs offline access to a Google API, set the API client's access type to offline : const authorizationUrl = oauth2Client . generateAuthUrl ({ // 'online' (default) or 'offline' (gets refresh_token) access_type : 'offline' , /** Pass in the scopes array defined above. * Alternatively, if only one scope is needed, you can pass a scope URL as a string */ scope : scopes , // Enable incremental authorization. Recommended as a best practice. include_granted_scopes : true }); After a user grants offline access to the requested scopes, you can continue to use the API client to access Google APIs on the user's behalf when the user is offline. The client object will refresh the access token as needed. Access tokens expire. This library will automatically use a refresh token to obtain a new access token if it is about to expire. An easy way to make sure you always store the most recent tokens is to use the tokens event: oauth2Client . on ( 'tokens' , ( tokens ) => { if ( tokens . refresh_token ) { // store the refresh_token in your secure persistent database console . log ( tokens . refresh_token ); } console . log ( tokens . access_token ); }); This tokens event only occurs in the first authorization, and you need to have set your access_type to offline when calling the generateAuthUrl method to receive the refresh token. If you have already given your app the requisiste permissions without setting the appropriate constraints for receiving a refresh token, you will need to re-authorize the application to receive a fresh refresh token. To set the refresh_token at a later time, you can use the setCredentials method: oauth2Client . setCredentials ({ refresh_token : `STORED_REFRESH_TOKEN` }); Once the client has a refresh token, access tokens will be acquired and refreshed automatically in the next call to the API. HTTP/REST To refresh an access token, your application sends an HTTPS POST request to Google's authorization server ( https://oauth2.googleapis.com/token ) that includes the following parameters: Fields client_id The client ID obtained from the API Console . client_secret The client secret obtained from the API Console . grant_type As defined in the OAuth 2.0 specification , this field's value must be set to refresh_token . refresh_token The refresh token returned from the authorization code exchange. The following snippet shows a sample request: POST /token HTTP/1.1 Host: oauth2.googleapis.com Content-Type: application/x-www-form-urlencoded client_id= your_client_id & client_secret= your_client_secret & refresh_token= refresh_token & grant_type=refresh_token As long as the user has not revoked the access granted to the application, the token server returns a JSON object that contains a new access token. The following snippet shows a sample response: { \"access_token\" : \"1/fFAGRNJru1FTz70BzhT3Zg\" , \"expires_in\" : 3920 , \"scope\" : \"https://www.googleapis.com/auth/drive.metadata.readonly\" , \"token_type\" : \"Bearer\" } Note that there are limits on the number of refresh tokens that will be issued; one limit per client/user combination, and another per user across all clients. You should save refresh tokens in long-term storage and continue to use them as long as they remain valid. If your application requests too many refresh tokens, it may run into these limits, in which case older refresh tokens will stop working. Revoking a token In some cases a user may wish to revoke access given to an application. A user can revoke access by visiting Account Settings . See the Remove site or app access section of the Third-party sites & apps with access to your account support document for more information. It is also possible for an application to programmatically revoke the access given to it. Programmatic revocation is important in instances where a user unsubscribes, removes an application, or the API resources required by an app have significantly changed. In other words, part of the removal process can include an API request to ensure the permissions previously granted to the application are removed. PHP To programmatically revoke a token, call revokeToken() : $client->revokeToken(); Python To programmatically revoke a token, make a request to https://oauth2.googleapis.com/revoke that includes the token as a parameter and sets the Content-Type header: requests . post ( 'https://oauth2.googleapis.com/revoke' , params = { 'token' : credentials . token }, headers = { 'content-type' : 'application/x-www-form-urlencoded' }) Ruby To programmatically revoke a token, make an HTTP request to the oauth2.revoke endpoint: uri = URI ( 'https://oauth2.googleapis.com/revoke' ) response = Net :: HTTP . post_form ( uri , 'token' => auth_client . access_token ) The token can be an access token or a refresh token. If the token is an access token and it has a corresponding refresh token, the refresh token will also be revoked. If the revocation is successfully processed, then the status code of the response is 200 . For error conditions, a status code 400 is returned along with an error code. Node.js To programmatically revoke a token, make an HTTPS POST request to /revoke endpoint: const https = require ( 'https' ); // Build the string for the POST request let postData = \"token=\" + userCredential . access_token ; // Options for POST request to Google's OAuth 2.0 server to revoke a token let postOptions = { host : 'oauth2.googleapis.com' , port : '443' , path : '/revoke' , method : 'POST' , headers : { 'Content-Type' : 'application/x-www-form-urlencoded' , 'Content-Length' : Buffer . byteLength ( postData ) } }; // Set up the request const postReq = https . request ( postOptions , function ( res ) { res . setEncoding ( 'utf8' ); res . on ( 'data' , d => { console . log ( 'Response: ' + d ); }); }); postReq . on ( 'error' , error => { console . log ( error ) }); // Post the request with data postReq . write ( postData ); postReq . end (); The token parameter can be an access token or a refresh token. If the token is an access token and it has a corresponding refresh token, the refresh token will also be revoked. If the revocation is successfully processed, then the status code of the response is 200 . For error conditions, a status code 400 is returned along with an error code. HTTP/REST To programmatically revoke a token, your application makes a request to https://oauth2.googleapis.com/revoke and includes the token as a parameter: curl -d -X -POST --header \"Content-type:application/x-www-form-urlencoded\" \\ https://oauth2.googleapis.com/revoke?token= {token} The token can be an access token or a refresh token. If the token is an access token and it has a corresponding refresh token, the refresh token will also be revoked. If the revocation is successfully processed, then the HTTP status code of the response is 200 . For error conditions, an HTTP status code 400 is returned along with an error code. Note: Following a successful revocation response, it might take some time before the revocation has full effect. Implementing Cross-Account Protection An additional step you should take to protect your users' accounts is implementing Cross-Account Protection by utilizing Google's Cross-Account Protection Service. This service lets you subscribe to security event notifications which provide information to your application about major changes to the user account. You can then use the information to take action depending on how you decide to respond to events. Some examples of the event types sent to your app by Google's Cross-Account Protection Service are: - https://schemas.openid.net/secevent/risc/event-type/sessions-revoked - https://schemas.openid.net/secevent/oauth/event-type/token-revoked - https://schemas.openid.net/secevent/risc/event-type/account-disabled See the Protect user accounts with Cross-Account Protection page for more information on how to implement Cross Account Protection and for the full list of available events. Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License , and code samples are licensed under the Apache 2.0 License . For details, see the Google Developers Site Policies . Java is a registered trademark of Oracle and/or its affiliates. Last updated 2024-09-03 UTC. Need to tell us more? [[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2024-09-03 UTC.\"],[],[]] - GitHub Fork our samples and try them yourself - Stack Overflow Ask a question under the google-oauth tag - Blog The latest news on the Google Developers blog - Product Info - Terms of Service - APIs User Data Policy - Branding Guidelines - Stack Overflow - Google Identity - Sign In With Google - Google OAuth 2.0 and OpenID Connect - Google Account Linking - Developer consoles - Google API Console - Google Cloud Platform Console - Google Play Console - Firebase Console - Actions on Google Console - Cast SDK Developer Console - Chrome Web Store Dashboard - Google Home Developer Console - Android - Chrome - Firebase - Google Cloud Platform - Google AI - All products - Terms - Privacy - Manage cookies - Sign up for the Google for Developers newsletter Subscribe - English - Deutsch - Español - Español – América Latina - Français - Indonesia - Italiano - Polski - Português – Brasil - Tiếng Việt - Türkçe - Русский - עברית - العربيّة - فارسی - हिंदी - বাংলা - ภาษาไทย - 中文 – 简体 - 中文 – 繁體 - 日本語 - 한국어",
    "cleanedHTML": "",
    "fullHTML": "",
    "textStatistics": {
      "sentenceCount": 0,
      "paragraphCount": 0,
      "averageWordsPerSentence": 0,
      "readabilityScore": 0
    }
  },
  "seoScores": {
    "overallScore": 85,
    "contentScore": 90,
    "technicalScore": 80,
    "userExperienceScore": 88,
    "socialScore": 75
  },
  "additionalInsights": {
    "keywordRelevanceScore": 92,
    "contentDepthScore": 88,
    "estimatedTraffic": 5000,
    "pageAuthority": 60
  }
}